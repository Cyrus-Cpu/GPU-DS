# ç™¾å®¶æ¨‚ AI ç®—ç‰Œé æ¸¬ v3.8.4 - GPU-DP-V2.1.1ï¼ˆé«˜æ¨è–¦ç‡å„ªåŒ–ç‰ˆï¼‰
# å®Œæ•´æ¢å¾©v3.8.4ç•Œé¢ + GPUè¶¨å‹¢ç´¯ç©ä¿®å¾© + ç²¾æº–åå‘é‚è¼¯ + é«˜æ¨è–¦ç‡å„ªåŒ–
# ä¿®æ”¹æ—¥æœŸï¼š2024å¹´
# å„ªåŒ–é‡é»ï¼šæ¨è–¦ç‡å¾14.3%æå‡è‡³45-65%

import tkinter as tk
from tkinter import ttk, messagebox, filedialog
import random
from collections import defaultdict
import math
import csv
import os
from datetime import datetime
import threading
import time

# å˜—è©¦å°å…¥ GPU ç›¸é—œåº«
try:
    import cupy as cp
    import numpy as np
    from numba import cuda
    GPU_AVAILABLE = True
    print("âœ“ GPUåŠ é€Ÿå¯ç”¨ - CuPyå·²è¼‰å…¥")
except ImportError as e:
    print(f"âœ—âœ— GPUåŠ é€Ÿä¸å¯ç”¨: {e}")
    GPU_AVAILABLE = False

# å˜—è©¦å°å…¥ matplotlib
try:
    import matplotlib
    matplotlib.use('TkAgg')
    import matplotlib.pyplot as plt
    from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
    
    # === ç°¡å–®ä¿®å¾©ï¼šæ·»åŠ ä¸­æ–‡å­—é«”è¨­ç½® ===
    plt.rcParams['font.sans-serif'] = ['Microsoft YaHei', 'SimHei', 'DejaVu Sans']
    plt.rcParams['axes.unicode_minus'] = False
    # =================================
    
    MATPLOTLIB_AVAILABLE = True
    print("âœ“ matplotlib å¯ç”¨ - ä¸­æ–‡å­—é«”å·²è¨­ç½®")
except ImportError:
    MATPLOTLIB_AVAILABLE = False
    print("âœ—âœ— matplotlib ä¸å¯ç”¨")

# ç²¾æº–åå‘é‚è¼¯ç³»çµ± - å¤šç¶­åº¦åå‘ä¿¡è™Ÿæª¢æ¸¬
def should_reverse_bet(bet_type, current_prob, percentage_change, acceleration, trend_state, threshold):
    """å¤šç¶­åº¦åˆ¤æ–·æ˜¯å¦æ‡‰è©²åå‘ä¸‹æ³¨"""
    
    # ä¿¡è™Ÿ1: æ¦‚ç‡éé«˜ä½†è¶¨å‹¢è¡°æ¸›
    if current_prob > 48.0 and acceleration < -0.1:
        return True
    
    # ä¿¡è™Ÿ2: è®ŠåŒ–ç‡èˆ‡è¶¨å‹¢å¼·åº¦èƒŒé›¢
    if (percentage_change > 1.0 and trend_state['trend_strength'][bet_type] < -0.5):
        return True
    
    # ä¿¡è™Ÿ3: é€£çºŒåŒå‘è®ŠåŒ–å¾Œçš„è½‰æŠ˜é»
    change_history = trend_state['change_history'][bet_type]
    if len(change_history) >= 3:
        # å¦‚æœé€£çºŒ3æ¬¡åŒå‘è®ŠåŒ–ï¼Œå¯èƒ½å‡ºç¾åè½‰
        if all(c > 0 for c in change_history[-3:]) and acceleration < -0.2:
            return True
        if all(c < 0 for c in change_history[-3:]) and acceleration > 0.2:
            return True
    
    # ä¿¡è™Ÿ4: æ¥µç«¯æ¦‚ç‡å€¼çš„å‡å€¼å›æ­¸
    if current_prob > 49.5 or current_prob < 42.0:
        return True
    
    # ä¿¡è™Ÿ5: ç´¯ç©è®ŠåŒ–éåº¦å¾Œçš„ä¿®æ­£
    if abs(trend_state['cumulative_changes'][bet_type]) > 3.0:
        return True
    
    return False

# åå‘é‚è¼¯åˆ†ç´šç³»çµ±
def get_reverse_bet_level(bet_type, current_prob, percentage_change, acceleration, trend_state):
    """æ ¹æ“šåå‘ä¿¡è™Ÿå¼·åº¦ç¢ºå®šä¸‹æ³¨ç­‰ç´š"""
    
    reverse_signals = 0
    signal_strength = 0
    
    # ä¿¡è™Ÿå¼·åº¦è¨ˆç®—
    if current_prob > 48.5:
        reverse_signals += 1
        signal_strength += (current_prob - 48.5) * 2
    
    if acceleration < -0.15:
        reverse_signals += 1
        signal_strength += abs(acceleration) * 10
    
    if abs(trend_state['cumulative_changes'][bet_type]) > 2.5:
        reverse_signals += 1
        signal_strength += abs(trend_state['cumulative_changes'][bet_type]) * 0.5
    
    # è¶¨å‹¢èƒŒé›¢æª¢æ¸¬
    if (percentage_change > 0 and trend_state['trend_strength'][bet_type] < -1.0) or \
       (percentage_change < 0 and trend_state['trend_strength'][bet_type] > 1.0):
        reverse_signals += 2
        signal_strength += 2.0
    
    # ç¢ºå®šåå‘ä¸‹æ³¨ç­‰ç´š
    if reverse_signals >= 3 and signal_strength > 3.0:
        return 3  # å¼·çƒˆåå‘ä¿¡è™Ÿ
    elif reverse_signals >= 2 and signal_strength > 1.5:
        return 2  # ä¸­ç­‰åå‘ä¿¡è™Ÿ
    elif reverse_signals >= 1 and signal_strength > 0.5:
        return 1  # å¼±åå‘ä¿¡è™Ÿ
    else:
        return 0  # ç„¡åå‘ä¿¡è™Ÿ

# æ”¹é€²çš„é–¾é–¾å€¼å­—å…¸ - å°ˆæ³¨åå‘é‚è¼¯
reverse_thresholds_dict = {
    "banker": {
        # èŠå®¶éåº¦æ¨‚è§€ -> åå‘ä¸‹æ³¨é–’å®¶
        "reverse_1": {
            "min_prob": 48.0, "max_prob": 52.0,  # æ¦‚ç‡éé«˜
            "min_change": 0.5, "max_change": 100.0,  # æœ‰æ˜é¡¯è®ŠåŒ–
            "min_accel": -0.3, "max_accel": 0.0,  # åŠ é€Ÿç‚ºè² ï¼ˆè¡°æ¸›ï¼‰
            "min_trend_strength": -2.0,  # è¶¨å‹¢å¼·åº¦ç‚ºè² 
            "min_cumulative": 2.0,  # ç´¯ç©è®ŠåŒ–éåº¦
            "level": 2, "win_rate": 52.5
        },
        "reverse_2": {
            "min_prob": 47.0, "max_prob": 49.0,
            "min_change": 1.0, "max_change": 100.0,
            "min_accel": -0.2, "max_accel": 0.0,
            "min_trend_strength": -1.0,
            "min_cumulative": 1.5,
            "level": 1, "win_rate": 51.0
        }
    },
    "player": {
        # é–’å®¶éåº¦æ¨‚è§€ -> åå‘ä¸‹æ³¨èŠå®¶
        "reverse_1": {
            "min_prob": 46.0, "max_prob": 50.0,
            "min_change": 0.5, "max_change": 100.0,
            "min_accel": -0.3, "max_accel": 0.0,
            "min_trend_strength": -2.0,
            "min_cumulative": 2.0,
            "level": 2, "win_rate": 53.0
        },
        "reverse_2": {
            "min_prob": 45.0, "max_prob": 47.0,
            "min_change": 1.0, "max_change": 100.0,
            "min_accel": -0.2, "max_accel": 0.0,
            "min_trend_strength": -1.0,
            "min_cumulative": 1.5,
            "level": 1, "win_rate": 51.5
        }
    }
}

# æ™‚é–“åºåˆ—æ¨¡å¼è­˜åˆ¥
def detect_reversal_pattern(change_history, current_change, acceleration):
    """æª¢æ¸¬åƒ¹æ ¼åè½‰æ¨¡å¼"""
    if len(change_history) < 4:
        return False
    
    recent_changes = change_history[-4:] + [current_change]
    
    # æ¨¡å¼1: é€£çºŒä¸Šæ¼²å¾Œçš„ä¸‹è·Œ
    if (all(c > 0 for c in recent_changes[:-2]) and 
        recent_changes[-2] < 0 and recent_changes[-1] < 0 and
        acceleration < -0.1):
        return True
    
    # æ¨¡å¼2: é€£çºŒä¸‹è·Œå¾Œçš„ä¸Šæ¼²
    if (all(c < 0 for c in recent_changes[:-2]) and 
        recent_changes[-2] > 0 and recent_changes[-1] > 0 and
        acceleration > 0.1):
        return True
    
    # æ¨¡å¼3: é«˜é»èƒŒé›¢ï¼ˆåƒ¹æ ¼æ–°é«˜ä½†å‹•èƒ½è¡°æ¸›ï¼‰
    if (max(recent_changes[:-1]) > 1.0 and 
        current_change < max(recent_changes[:-1]) * 0.5 and
        acceleration < -0.15):
        return True
    
    return False

# å®Œæ•´çš„æ”¹é€²åå‘é‚è¼¯å¯¦ç¾
def improved_reverse_evaluation(bet_type, current_prob, percentage_change, acceleration, trend_state, other_param, threshold=0.5):  
    """æ”¹é€²çš„åå‘ä¸‹æ³¨è©•ä¼°"""
    
    # åŸºç¤æ¢ä»¶æª¢æŸ¥
    if current_prob < threshold.get("min_prob", 0) or current_prob > threshold.get("max_prob", 100):
        return None, 0
    
    if not (threshold["min_change"] <= abs(percentage_change) < threshold["max_change"]):
        return None, 0
    
    if not (threshold["min_accel"] <= acceleration <= threshold.get("max_accel", 100)):
        return None, 0
    
    # å¤šç¶­åº¦åå‘ä¿¡è™Ÿæª¢æ¸¬
    reverse_signals = []
    
    # ä¿¡è™Ÿ1: è¶¨å‹¢å¼·åº¦èƒŒé›¢
    if trend_state['trend_strength'][bet_type] < threshold.get("min_trend_strength", 0):
        reverse_signals.append(1)
    
    # ä¿¡è™Ÿ2: ç´¯ç©è®ŠåŒ–éåº¦
    if abs(trend_state['cumulative_changes'][bet_type]) > threshold.get("min_cumulative", 0):
        reverse_signals.append(1)
    
    # ä¿¡è™Ÿ3: æ¦‚ç‡æ¥µå€¼
    if current_prob > 48.5 or current_prob < 42.0:
        reverse_signals.append(1)
    
    # ä¿¡è™Ÿ4: æ™‚é–“åºåˆ—åè½‰æ¨¡å¼
    if detect_reversal_pattern(trend_state['change_history'][bet_type], percentage_change, acceleration):
        reverse_signals.append(2)  # æ›´å¼·çš„ä¿¡è™Ÿ
    
    # ç¢ºå®šåå‘ä¸‹æ³¨
    if len(reverse_signals) >= 2 and sum(reverse_signals) >= 2:
        final_bet_type = 'player' if bet_type == 'banker' else 'banker'
        
        # æ ¹æ“šä¿¡è™Ÿå¼·åº¦ç¢ºå®šä¸‹æ³¨ç­‰ç´š
        signal_strength = sum(reverse_signals)
        if signal_strength >= 4:
            reverse_level = min(5, threshold["level"] + 2)
        elif signal_strength >= 3:
            reverse_level = min(3, threshold["level"] + 1)
        else:
            reverse_level = threshold["level"]
        
        return final_bet_type, reverse_level
    
    return None, 0

# æ ¹æ“šGPUæ¨¡æ“¬çµæœ0.3å¿«é€Ÿåˆ†æè¨­å®šçš„æ–°é–¾é–¾å€¼ - V2.1.1é«˜æ¨è–¦ç‡å„ªåŒ–ç‰ˆ
thresholds_dict = {
    "banker": {
        # æ–°å¢å¯¬é¬†ç´šåˆ¥ - é«˜æ¨è–¦ç‡å„ªåŒ–
        "0": {"min_change": 0.0, "max_change": 0.3, "min_accel": 0.0, "min_prob": 45.0, "level": 1, "win_rate": 50.1},
        "1": {"min_change": 0.0, "max_change": 0.5, "min_accel": 0.0, "min_prob": 45.5, "level": 2, "win_rate": 50.2},
        # æ­£å‘æŒ‡æ¨™ - èŠå®¶ï¼ˆå‹ç‡â‰¥49%ï¼‰
        "2": {"min_change": 0.5, "max_change": 1.0, "min_accel": 0.05, "min_prob": 46.0, "level": 3, "win_rate": 50.3},
        "3": {"min_change": 1.0, "max_change": 1.5, "min_accel": 0.1, "min_prob": 46.5, "level": 4, "win_rate": 50.4},
        "4": {"min_change": 1.5, "max_change": 2.0, "min_accel": 0.15, "min_prob": 47.0, "level": 5, "win_rate": 50.5},
        "5": {"min_change": 2.0, "max_change": 100.0, "min_accel": 0.2, "min_prob": 47.5, "level": 10, "win_rate": 50.6},
        # åå‘æŒ‡æ¨™ - èŠå®¶ï¼ˆå‹ç‡<49%ï¼‰
        "6": {"min_change": 0.0, "max_change": 0.5, "min_accel": 0.0, "min_prob": 44.5, "reverse": True, "level": 1, "win_rate": 48.8},
        "7": {"min_change": 0.5, "max_change": 1.0, "min_accel": 0.05, "min_prob": 45.0, "reverse": True, "level": 1, "win_rate": 48.5}
    },
    "player": {
        # æ–°å¢å¯¬é¬†ç´šåˆ¥ - é«˜æ¨è–¦ç‡å„ªåŒ–
        "0": {"min_change": 0.0, "max_change": 0.3, "min_accel": 0.0, "min_prob": 43.5, "level": 1, "win_rate": 51.5},
        "1": {"min_change": 0.0, "max_change": 0.5, "min_accel": 0.0, "min_prob": 44.0, "level": 2, "win_rate": 51.8},
        # æ­£å‘æŒ‡æ¨™ - é–’å®¶ï¼ˆå‹ç‡â‰¥49%ï¼‰
        "2": {"min_change": 1.0, "max_change": 100.0, "min_accel": 0.05, "min_prob": 44.5, "level": 5, "win_rate": 52.0},
        "3": {"min_change": 1.0, "max_change": 100.0, "min_accel": 0.08, "min_prob": 45.0, "level": 10, "win_rate": 52.2},
        # åå‘æŒ‡æ¨™ - é–’å®¶ï¼ˆå‹ç‡<49%ï¼‰
        "4": {"min_change": 0.0, "max_change": 0.5, "min_accel": 0.0, "min_prob": 43.5, "reverse": True, "level": 1, "win_rate": 49.8},
        "5": {"min_change": 0.5, "max_change": 1.0, "min_accel": 0.05, "min_prob": 44.0, "reverse": True, "level": 1, "win_rate": 49.6},
        "6": {"min_change": 0.0, "max_change": 100.0, "min_accel": 0.0, "min_prob": 45.0, "reverse": True, "level": 1, "win_rate": 46.0},
        "7": {"min_change": 0.0, "max_change": 100.0, "min_accel": 0.0, "min_prob": 45.5, "reverse": True, "level": 1, "win_rate": 43.5}
    },
    "tie": {
        "1": {"min_change": 100.0, "max_change": 0.0, "min_accel": 100.0, "min_prob": 0.0, "level": 0, "win_rate": 0.0},
        "2": {"min_change": 100.0, "max_change": 0.0, "min_accel": 100.0, "min_prob": 0.0, "level": 0, "win_rate": 0.0},
        "3": {"min_change": 100.0, "max_change": 0.0, "min_accel": 100.0, "min_prob": 0.0, "level": 0, "win_rate": 0.0},
        "4": {"min_change": 100.0, "max_change": 0.0, "min_accel": 100.0, "min_prob": 0.0, "level": 0, "win_rate": 0.0},
        "5": {"min_change": 100.0, "max_change": 0.0, "min_accel": 100.0, "min_prob": 0.0, "level": 0, "win_rate": 0.0}
    }
}

card_values = {
    'A': 1, '2': 2, '3': 3, '4': 4, '5': 5, 
    '6': 6, '7': 7, '8': 8, '9': 9, '10': 0, 
    'J': 0, 'Q': 0, 'K': 0
}
card_names = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K']

class BaccaratGPUSimulator:
    def __init__(self):
        global GPU_AVAILABLE
        if GPU_AVAILABLE:
            try:
                self.device = cp.cuda.Device(0)
                self.device.use()
                print(f"âœ“ GPUæ¨¡æ“¬å™¨åˆå§‹åŒ– - v3.8.4é«˜æ¨è–¦ç‡å„ªåŒ–ç³»çµ±")
            except Exception as e:
                print(f"âœ—âœ— GPUè¨­å‚™åˆå§‹åŒ–å¤±æ•—: {e}")
                GPU_AVAILABLE = False
        else:
            print("âœ—âœ— GPUä¸å¯ç”¨ï¼Œä½¿ç”¨CPUæ¨¡æ“¬")
        
        # èˆ‡ä¸»ç¨‹å¼å®Œå…¨ç›¸åŒçš„é…ç½®
        self.base_probabilities = {
            'banker': 45.851, 'player': 44.695, 'tie': 9.454
        }
        self.card_values = card_values
        self.decks = 10
        self.card_names = card_names
        
        # è¶¨å‹¢ç³»çµ±ç‹€æ…‹ï¼ˆèˆ‡ä¸»ç¨‹å¼å®Œå…¨åŒæ­¥ï¼‰- V2.1.1é«˜æ¨è–¦ç‡å„ªåŒ–åƒæ•¸
        self._reset_trend_state()
        
        # èª¿è©¦çµ±è¨ˆ
        self.debug_stats = {
            'total_recommendations': 0,
            'banker_recommendations': 0,
            'player_recommendations': 0,
            'no_recommendations': 0,
            'reverse_recommendations': 0
        }

    def _reset_trend_state(self):
        """é‡ç½®è¶¨å‹¢ç‹€æ…‹ï¼ˆèˆ‡ä¸»ç¨‹å¼ç›¸åŒï¼‰- V2.1.1å„ªåŒ–åƒæ•¸"""
        self.trend_state = {
            'previous_changes': {'banker': 0.0, 'player': 0.0, 'tie': 0.0},
            'trend_strength': {'banker': 0.0, 'player': 0.0, 'tie': 0.0},
            'cumulative_changes': {'banker': 0.0, 'player': 0.0, 'tie': 0.0},
            'consecutive_no_recommendation': 0,
            'change_history': {'banker': [], 'player': [], 'tie': []},
            'trend_decay_counter': {'banker': 0, 'player': 0, 'tie': 0}
        }

    def mass_simulation(self, num_simulations=10000):
        """å¤§è¦æ¨¡æ¨¡æ“¬ - v3.8.4é«˜æ¨è–¦ç‡å„ªåŒ–ç‰ˆæœ¬"""
        start_time = time.time()
        
        try:
            # é‡ç½®è¶¨å‹¢ç‹€æ…‹å’Œçµ±è¨ˆ
            self._reset_trend_state()
            self.debug_stats = {
                'total_recommendations': 0,
                'banker_recommendations': 0, 
                'player_recommendations': 0,
                'no_recommendations': 0,
                'reverse_recommendations': 0
            }
            
            if GPU_AVAILABLE:
                results = self._gpu_accelerated_simulation(num_simulations)
            else:
                results = self._cpu_fallback_simulation(num_simulations)
            
            end_time = time.time()
            simulation_time = end_time - start_time
            
            results['performance'] = {
                'total_time': simulation_time,
                'games_per_second': num_simulations / simulation_time,
                'num_simulations': num_simulations
            }
            
            # è¼¸å‡ºèª¿è©¦çµ±è¨ˆ
            total_games = num_simulations
            rec_rate = (self.debug_stats['total_recommendations'] / total_games) * 100
            reverse_rate = (self.debug_stats['reverse_recommendations'] / total_games) * 100
            print(f"âœ“ v3.8.4é«˜æ¨è–¦ç‡æ¨¡æ“¬å®Œæˆ: {num_simulations}å±€")
            print(f"ğŸ“ŠğŸ“Š æ¨è–¦çµ±è¨ˆ: èŠ{self.debug_stats['banker_recommendations']} é–’{self.debug_stats['player_recommendations']} ç„¡{self.debug_stats['no_recommendations']}")
            print(f"ğŸ”„ğŸ”„ åå‘æ¨è–¦: {self.debug_stats['reverse_recommendations']}å±€ ({reverse_rate:.1f}%)")
            print(f"ğŸ“ˆğŸ“ˆ æ¨è–¦ç‡: {rec_rate:.1f}% (ç›®æ¨™: 45-65%)")
            
            return results
            
        except Exception as e:
            print(f"âœ—âœ— æ¨¡æ“¬éŒ¯èª¤: {e}")
            return self._cpu_fallback_simulation(num_simulations)

    def _gpu_accelerated_simulation(self, num_simulations):
        """GPUåŠ é€Ÿæ¨¡æ“¬ - v3.8.4é«˜æ¨è–¦ç‡å„ªåŒ–ç‰ˆ"""
        try:
            # ä½¿ç”¨æ›´å°çš„æ‰¹æ¬¡ç¢ºä¿è¶¨å‹¢é€£çºŒæ€§
            batch_size = min(500, num_simulations)  # âœ… ç»Ÿä¸€å˜é‡å
            results = {
                'banker_wins': 0,
                'player_wins': 0,
                'ties': 0,
                'banker_win_rate': 0.0,
                'player_win_rate': 0.0,
                'tie_rate': 0.0,
                'performance': {},
                'detailed_results': []
            }
            
            # åˆå§‹åŒ–ç‰Œå †å’Œè¶¨å‹¢ç‹€æ…‹
            current_deck = self.initialize_deck_gpu()
            random.shuffle(current_deck)
            
            # ä¿®å¾©ï¼šç›´æ¥å¼•ç”¨ä¸»è¶¨å‹¢ç‹€æ…‹ï¼Œä¸å†è¤‡è£½
            trend_state = self.trend_state
            
            completed_games = 0
            batch_count = 0
            
            while completed_games < num_simulations:
                batch_count += 1
                current_batch_size = min(batch_size, num_simulations - completed_games)
                
                batch_results = self._simulate_batch(current_batch_size, current_deck, trend_state)
                current_deck = batch_results['remaining_deck']
                
                # ä¿®å¾©ï¼šè¶¨å‹¢ç‹€æ…‹å·²åœ¨æ‰¹æ¬¡ä¸­ç›´æ¥æ›´æ–°ï¼Œç„¡éœ€é‡æ–°è³¦å€¼
                # trend_state = batch_results['final_trend_state']
                
                results['banker_wins'] += batch_results['banker_wins']
                results['player_wins'] += batch_results['player_wins']
                results['ties'] += batch_results['ties']
                results['detailed_results'].extend(batch_results['detailed_results'])
                
                completed_games += current_batch_size
                
                # é€²åº¦è¼¸å‡º
                if batch_count % 10 == 0:
                    progress = (completed_games / num_simulations) * 100
                    print(f"ğŸ”„ğŸ”„ GPUæ¨¡æ“¬é€²åº¦: {completed_games}/{num_simulations} ({progress:.1f}%)")
                
                # é‡‹æ”¾GPUå…§å­˜
                if GPU_AVAILABLE:
                    cp.get_default_memory_pool().free_all_blocks()
            
            total_games = num_simulations
            results['banker_win_rate'] = results['banker_wins'] / total_games * 100
            results['player_win_rate'] = results['player_wins'] / total_games * 100
            results['tie_rate'] = results['ties'] / total_games * 100
            
            return results
            
        except Exception as e:
            print(f"âœ—âœ— GPUæ¨¡æ“¬éŒ¯èª¤: {e}")
            raise

    def _simulate_batch(self, batch_size, current_deck, trend_state):
        """æ‰¹æ¬¡æ¨¡æ“¬ - è¿”å›æœ€çµ‚è¶¨å‹¢ç‹€æ…‹"""
        banker_wins = 0
        player_wins = 0
        ties = 0
        detailed_results = []
        
        for i in range(batch_size):
            result = self._simulate_single_game_cpu(i, current_deck, trend_state)
            current_deck = result['remaining_deck']
            # trend_state åœ¨ _simulate_single_game_cpu ä¸­å·²ç¶“è¢«æ›´æ–°
            
            if result['winner'] == 'banker':
                banker_wins += 1
            elif result['winner'] == 'player':
                player_wins += 1
            else:
                ties += 1
            
            detailed_results.append(result)
            
            # æ›´æ–°èª¿è©¦çµ±è¨ˆ
            if result['recommendation']:
                self.debug_stats['total_recommendations'] += 1
                if result['recommendation'] == 'banker':
                    self.debug_stats['banker_recommendations'] += 1
                else:
                    self.debug_stats['player_recommendations'] += 1
                
                # æª¢æŸ¥æ˜¯å¦ç‚ºåå‘æ¨è–¦
                if result.get('is_reverse', False):
                    self.debug_stats['reverse_recommendations'] += 1
            else:
                self.debug_stats['no_recommendations'] += 1
        
        return {
            'banker_wins': banker_wins,
            'player_wins': player_wins,
            'ties': ties,
            'detailed_results': detailed_results,
            'remaining_deck': current_deck,
            'final_trend_state': trend_state  # è¿”å›æœ€çµ‚è¶¨å‹¢ç‹€æ…‹
        }

    def _simulate_single_game_cpu(self, game_id, remaining_deck, trend_state):
        """å–®å±€æ¨¡æ“¬ - å®Œå…¨è¤‡è£½CPUé‚è¼¯"""
        # ç‰Œå †ç®¡ç†ï¼ˆèˆ‡CPUç›¸åŒï¼‰
        if remaining_deck is None or len(remaining_deck) < 6:
            deck = self.initialize_deck_gpu()
            random.shuffle(deck)
        else:
            deck = remaining_deck.copy()
        
        # æ¨¡æ“¬ç‰Œå±€ï¼ˆèˆ‡CPUå®Œå…¨ç›¸åŒï¼‰
        player_hand = [deck.pop(0), deck.pop(0)]
        banker_hand = [deck.pop(0), deck.pop(0)]
        
        player_score = sum(self.card_values[card] for card in player_hand) % 10
        banker_score = sum(self.card_values[card] for card in banker_hand) % 10
        player_drew = False
        player_third_card_value = None
        
        # ç©å®¶æŠ½ç‰Œè¦å‰‡ï¼ˆèˆ‡ä¸»ç¨‹å¼ç›¸åŒï¼‰
        if player_score <= 5:
            if len(deck) > 0:
                player_third_card = deck.pop(0)
                player_hand.append(player_third_card)
                player_score = sum(self.card_values[card] for card in player_hand) % 10
                player_drew = True
                player_third_card_value = self.card_values[player_third_card]
        
        # èŠå®¶æŠ½ç‰Œè¦å‰‡ï¼ˆèˆ‡ä¸»ç¨‹å¼ç›¸åŒï¼‰
        if banker_score <= 2:
            if len(deck) > 0:
                banker_third_card = deck.pop(0)
                banker_hand.append(banker_third_card)
                banker_score = sum(self.card_values[card] for card in banker_hand) % 10
        elif banker_score == 3 and player_drew and player_third_card_value != 8:
            if len(deck) > 0:
                banker_third_card = deck.pop(0)
                banker_hand.append(banker_third_card)
                banker_score = sum(self.card_values[card] for card in banker_hand) % 10
        elif banker_score == 4 and player_drew and player_third_card_value in [2,3,4,5,6,7]:
            if len(deck) > 0:
                banker_third_card = deck.pop(0)
                banker_hand.append(banker_third_card)
                banker_score = sum(self.card_values[card] for card in banker_hand) % 10
        elif banker_score == 5 and player_drew and player_third_card_value in [4,5,6,7]:
            if len(deck) > 0:
                banker_third_card = deck.pop(0)
                banker_hand.append(banker_third_card)
                banker_score = sum(self.card_values[card] for card in banker_hand) % 10
        elif banker_score == 6 and player_drew and player_third_card_value in [6,7]:
            if len(deck) > 0:
                banker_third_card = deck.pop(0)
                banker_hand.append(banker_third_card)
                banker_score = sum(self.card_values[card] for card in banker_hand) % 10
        
        # è¨ˆç®—å‹è² 
        if banker_score > player_score:
            winner = 'banker'
            winner_chinese = 'èŠ'
        elif player_score > banker_score:
            winner = 'player'
            winner_chinese = 'é–’'
        else:
            winner = 'tie'
            winner_chinese = 'å’Œ'
        
        # è¨ˆç®—çœŸå¯¦æ¦‚ç‡ï¼ˆèˆ‡CPUç›¸åŒï¼‰
        probabilities = self._calculate_probabilities_from_deck(deck)
        
        # ä½¿ç”¨å®Œå…¨ç›¸åŒçš„æ¨è–¦é‚è¼¯ï¼ˆåŒ…å«ç²¾æº–åå‘é‚è¼¯ï¼‰
        recommendation, bet_level, is_reverse = self._get_recommendation_with_main_logic(
            probabilities, 
            trend_state
        )
        
        # æ›´æ–°è¶¨å‹¢ç‹€æ…‹ï¼ˆèˆ‡CPUç›¸åŒï¼‰
        self._update_trend_state(trend_state, probabilities, recommendation)
        
        # ç”Ÿæˆçµæœ
        result_text = self._generate_result_text(recommendation, winner, winner_chinese, is_reverse)
        
        return {
            'game_id': game_id,
            'banker_hand': banker_hand,
            'player_hand': player_hand,
            'banker_score': banker_score,
            'player_score': player_score,
            'winner': winner,
            'winner_chinese': winner_chinese,
            'probabilities': probabilities,
            'recommendation': recommendation,
            'bet_level': bet_level,
            'is_reverse': is_reverse,
            'result_text': result_text,
            'result': 'âœ“' if recommendation == winner else 'âœ—âœ—' if recommendation else 'ç„¡',
            'remaining_deck': deck,
            'changes': self._calculate_changes(probabilities),
            'trend_state': trend_state
        }

    def _calculate_probabilities_from_deck(self, deck):
        """è¨ˆç®—åŸºæ–¼å‰©é¤˜ç‰Œå †çš„çœŸå¯¦æ¦‚ç‡ï¼ˆèˆ‡ä¸»ç¨‹å¼å®Œå…¨ä¸€è‡´ï¼‰"""
        total_cards = len(deck)
        total_initial_cards = self.decks * 52
        
        if total_cards < 20:  # èˆ‡ä¸»ç¨‹å¼ç›¸åŒçš„é‡æ–°æ´—ç‰Œæ¢ä»¶
            return self.base_probabilities.copy()
        
        # è¨ˆç®—å„é»æ•¸ç‰Œçš„æ•¸é‡ï¼ˆèˆ‡ä¸»ç¨‹å¼ç›¸åŒï¼‰
        card_counts = {}
        for card in self.card_names:
            count = deck.count(card)
            card_counts[card] = count
        
        point_ratios = {}
        for point in range(0, 10):
            if point == 0:
                cards_for_point = ['10', 'J', 'Q', 'K']
            else:
                cards_for_point = [card for card in self.card_names if self.card_values[card] == point]
            
            total_count = sum(card_counts[card] for card in cards_for_point)
            point_ratios[point] = total_count / total_cards
        
        # èˆ‡ä¸»ç¨‹å¼å®Œå…¨ç›¸åŒçš„èª¿æ•´å…¬å¼
        high_card_ratio = point_ratios[0]
        low_card_ratio = sum(point_ratios[i] for i in [1, 2, 3, 4, 5])
        medium_card_ratio = sum(point_ratios[i] for i in [6, 7])
        eight_nine_ratio = sum(point_ratios[i] for i in [8, 9])
        
        banker_adjust = (eight_nine_ratio - 0.158) * 8 - (low_card_ratio - 0.385) * 4
        player_adjust = (low_card_ratio - 0.385) * 8 - (eight_nine_ratio - 0.158) * 4
        tie_adjust = (medium_card_ratio - 0.308) * 6
        
        # æ¶ˆè€—æ•ˆæ‡‰ï¼ˆèˆ‡ä¸»ç¨‹å¼ç›¸åŒï¼‰
        consumption_ratio = (total_initial_cards - total_cards) / total_initial_cards
        consumption_effect = consumption_ratio * 2
        
        # èˆ‡ä¸»ç¨‹å¼ç›¸åŒçš„æ¦‚ç‡è¨ˆç®—
        probabilities = {
            'banker': max(40.0, min(52.0, self.base_probabilities['banker'] + banker_adjust + consumption_effect)),
            'player': max(40.0, min(52.0, self.base_probabilities['player'] + player_adjust - consumption_effect)),
            'tie': max(5.0, min(15.0, self.base_probabilities['tie'] + tie_adjust))
        }
        
        # æ­£è¦åŒ–ï¼ˆèˆ‡ä¸»ç¨‹å¼ç›¸åŒï¼‰
        total = sum(probabilities.values())
        if total > 0:
            scale = 100.0 / total
            for key in probabilities:
                probabilities[key] = round(probabilities[key] * scale, 3)
        
        return probabilities

    def _get_recommendation_with_main_logic(self, probabilities, trend_state):
        """å®Œå…¨è¤‡è£½ä¸»ç¨‹å¼çš„æ¨è–¦é‚è¼¯ï¼ˆåŒ…å«ç²¾æº–åå‘é‚è¼¯ï¼‰"""
        banker_prob = probabilities['banker']
        player_prob = probabilities['player']
        
        # è¨ˆç®—è®ŠåŒ–ç‡ï¼ˆèˆ‡ä¸»ç¨‹å¼å®Œå…¨ç›¸åŒï¼‰
        base_probs = self.base_probabilities
        banker_change = ((banker_prob - base_probs['banker']) / base_probs['banker']) * 100
        player_change = ((player_prob - base_probs['player']) / base_probs['player']) * 100
        
        # è¨ˆç®—åŠ é€Ÿï¼ˆèˆ‡ä¸»ç¨‹å¼å®Œå…¨ç›¸åŒï¼‰
        previous_changes = trend_state['previous_changes']
        banker_acceleration = banker_change - previous_changes['banker']
        player_acceleration = player_change - previous_changes['player']
        
        # èŠå®¶æ¨è–¦åˆ¤æ–·ï¼ˆå®Œå…¨è¤‡è£½ä¸»ç¨‹å¼é‚è¼¯ + ç²¾æº–åå‘é‚è¼¯ï¼‰
        banker_recommendation = self._evaluate_bet_recommendation(
            'banker', banker_prob, banker_change, banker_acceleration, trend_state
        )
        
        # é–’å®¶æ¨è–¦åˆ¤æ–·ï¼ˆå®Œå…¨è¤‡è£½ä¸»ç¨‹å¼é‚è¼¯ + ç²¾æº–åå‘é‚è¼¯ï¼‰
        player_recommendation = self._evaluate_bet_recommendation(
            'player', player_prob, player_change, player_acceleration, trend_state
        )
        
        # é¸æ“‡æœ€ä½³æ¨è–¦ï¼ˆèˆ‡ä¸»ç¨‹å¼ç›¸åŒï¼‰
        recommendations = []
        if banker_recommendation and banker_recommendation['level'] > 0:
            recommendations.append(banker_recommendation)
        if player_recommendation and player_recommendation['level'] > 0:
            recommendations.append(player_recommendation)
        
        if recommendations:
            recommendations.sort(key=lambda x: (x['level'], abs(trend_state['trend_strength'][x['bet_type']])), reverse=True)
            best_rec = recommendations[0]
            return best_rec['bet_type'], best_rec['level'], best_rec.get('is_reverse', False)
        else:
            return None, 0, False

    def _evaluate_bet_recommendation(self, bet_type, current_prob, percentage_change, acceleration, trend_state):
        """è©•ä¼°ä¸‹æ³¨æ¨è–¦ï¼ˆå®Œå…¨è¤‡è£½ä¸»ç¨‹å¼é‚è¼¯ + ç²¾æº–åå‘é‚è¼¯ï¼‰- V2.1.1é«˜æ¨è–¦ç‡å„ªåŒ–"""
        if bet_type not in thresholds_dict:
            return None
        
        # å‹•æ…‹åŠ é€Ÿé–¾é–¾å€¼ï¼ˆèˆ‡ä¸»ç¨‹å¼ç›¸åŒï¼‰- V2.1.1å„ªåŒ–
        base_threshold = 0.01  # å¾0.05é™ä½åˆ°0.01ï¼ˆé«˜æ¨è–¦ç‡å„ªåŒ–ï¼‰
        consecutive_no_recommendation = trend_state['consecutive_no_recommendation']
        
        if consecutive_no_recommendation >= 15:  # å¾10å¢åŠ åˆ°15ï¼ˆæ”¾å¯¬æ‡²ç½°ï¼‰
            current_accel_threshold = base_threshold * 0.8  # å¾0.5å¢åŠ åˆ°0.8
        elif consecutive_no_recommendation >= 10:  # å¾6å¢åŠ åˆ°10
            current_accel_threshold = base_threshold * 0.9  # å¾0.7å¢åŠ åˆ°0.9
        elif consecutive_no_recommendation >= 5:   # å¾3å¢åŠ åˆ°5
            current_accel_threshold = base_threshold * 0.95  # å¾0.85å¢åŠ åˆ°0.95
        else:
            current_accel_threshold = base_threshold
        
        # è¶¨å‹¢éæ¿¾ï¼ˆèˆ‡ä¸»ç¨‹å¼ç›¸åŒï¼‰- V2.1.1å¤§å¹…æ”¾å¯¬
        if abs(trend_state['trend_strength'][bet_type]) < 0.0001:  # å¾0.0001ä¿æŒä¸è®Š
            return None
        
        final_bet_type = bet_type
        cumulative_bonus = 0
        is_reverse = False
        
        # V2.1.1å„ªåŒ–ï¼šå¤§å¹…é™ä½ç´¯ç©è®ŠåŒ–çå‹µé–€æª»
        if abs(trend_state['cumulative_changes'][bet_type]) > 0.3:  # å¾0.5é™ä½åˆ°0.3
            cumulative_bonus = min(3, int(abs(trend_state['cumulative_changes'][bet_type]) * 3))  # çå‹µå¢åŠ 
        
        # é¦–å…ˆæª¢æŸ¥ç²¾æº–åå‘é‚è¼¯
        reverse_bet, reverse_level = improved_reverse_evaluation(
            bet_type, current_prob, percentage_change, acceleration, 
            trend_state, reverse_thresholds_dict[bet_type].get("reverse_1", {})
        )
        
        if reverse_bet and reverse_level > 0:
            final_bet_type = reverse_bet
            base_level = reverse_level
            is_reverse = True
        else:
            # åŸæœ‰é–¾é–¾å€¼åˆ¤æ–·é‚è¼¯ï¼ˆèˆ‡ä¸»ç¨‹å¼å®Œå…¨ç›¸åŒï¼‰- V2.1.1æ–°å¢å¯¬é¬†ç´šåˆ¥
            for level in ['7', '6', '5', '4', '3', '2', '1', '0']:  # æ–°å¢'0'ç´šåˆ¥
                if level in thresholds_dict[bet_type]:
                    threshold = thresholds_dict[bet_type][level]
                    
                    if current_prob < threshold.get("min_prob", 0):
                        continue
                    
                    if (threshold["min_change"] <= abs(percentage_change) < threshold["max_change"] and 
                        acceleration >= threshold["min_accel"]):
                        
                        base_level = threshold["level"]
                        
                        if threshold.get("reverse", False) or threshold.get("win_rate", 50) < 49:
                            final_bet_type = 'player' if bet_type == 'banker' else 'banker'
                            base_level = 1
                            is_reverse = True
                        
                        if not threshold.get("reverse", False) and threshold.get("win_rate", 50) >= 49:
                            final_level = min(20, base_level + cumulative_bonus)
                        else:
                            final_level = base_level
                        
                        return {
                            'bet_type': final_bet_type,
                            'level': final_level,
                            'is_reverse': is_reverse
                        }
            
            return None
        
        # åå‘é‚è¼¯çš„ç­‰ç´šè¨ˆç®—
        if is_reverse:
            reverse_level_adjusted = get_reverse_bet_level(
                bet_type, current_prob, percentage_change, acceleration, trend_state
            )
            final_level = max(1, min(5, base_level + reverse_level_adjusted))
            
            return {
                'bet_type': final_bet_type,
                'level': final_level,
                'is_reverse': is_reverse
            }
        
        return None

    def _update_trend_state(self, trend_state, probabilities, recommendation):
        """æ›´æ–°è¶¨å‹¢ç‹€æ…‹ï¼ˆèˆ‡ä¸»ç¨‹å¼å®Œå…¨ç›¸åŒï¼‰- V2.1.1é«˜æ¨è–¦ç‡å„ªåŒ–"""
        # è¨ˆç®—è®ŠåŒ–ç‡
        current_changes = {}
        for bet_type in ['banker', 'player', 'tie']:
            current_prob = probabilities[bet_type]
            base_prob = self.base_probabilities[bet_type]
            current_changes[bet_type] = ((current_prob - base_prob) / base_prob) * 100
        
        # æ›´æ–°è¶¨å‹¢å¼·åº¦ï¼ˆèˆ‡ä¸»ç¨‹å¼ç›¸åŒçš„è¤‡é›œé‚è¼¯ï¼‰- V2.1.1å„ªåŒ–
        for bet_type in ['banker', 'player']:
            current_change = current_changes[bet_type]
            previous_change = trend_state['previous_changes'][bet_type]
            acceleration = current_change - previous_change
            
            # å®Œå…¨è¤‡è£½CPUçš„è¶¨å‹¢æ›´æ–°é‚è¼¯ - V2.1.1å¤§å¹…å„ªåŒ–
            current_strength = trend_state['trend_strength'][bet_type]
            
            # V2.1.1å„ªåŒ–ï¼šå¤§å¹…é™ä½åŠ é€Ÿè§¸ç™¼é–€æª»
            if acceleration > 0.01:  # åŠ é€Ÿé–¾é–¾å€¼å¾0.05é™ä½åˆ°0.01
                strength_increment = max(0.02, min(3.0, abs(acceleration) * 0.8))  # ä¹˜æ•¸å¾0.5å¢åŠ åˆ°0.8
                if current_strength > 12.0:  # å¾8.0å¢åŠ åˆ°12.0
                    strength_increment *= 0.8  # å¾0.6å¢åŠ åˆ°0.8
                elif current_strength > 8.0:   # å¾5.0å¢åŠ åˆ°8.0
                    strength_increment *= 0.9  # å¾0.8å¢åŠ åˆ°0.9
                trend_state['trend_strength'][bet_type] = min(25.0, current_strength + strength_increment)  # å¾15.0å¢åŠ åˆ°25.0
                trend_state['trend_decay_counter'][bet_type] = 0
            elif acceleration < -0.01:  # åŠ é€Ÿé–¾é–¾å€¼å¾0.05é™ä½åˆ°0.01
                strength_decrement = max(0.02, min(3.0, abs(acceleration) * 0.8))  # ä¹˜æ•¸å¾0.5å¢åŠ åˆ°0.8
                trend_state['trend_strength'][bet_type] = max(-25.0, current_strength - strength_decrement)  # å¾15.0å¢åŠ åˆ°25.0
                trend_state['trend_decay_counter'][bet_type] = 0
            else:
                trend_state['trend_decay_counter'][bet_type] += 1
                
                # è¡°æ¸›é‚è¼¯ï¼ˆèˆ‡CPUç›¸åŒï¼‰- V2.1.1å„ªåŒ–
                decay_rate = 0.02  # å¾0.03é™ä½åˆ°0.02
                if abs(current_strength) > 15.0:  # å¾10.0å¢åŠ åˆ°15.0
                    decay_rate = 0.10  # å¾0.12é™ä½åˆ°0.10
                elif abs(current_strength) > 10.0:  # å¾6.0å¢åŠ åˆ°10.0
                    decay_rate = 0.06  # å¾0.08é™ä½åˆ°0.06
                elif abs(current_strength) > 5.0:   # å¾3.0å¢åŠ åˆ°5.0
                    decay_rate = 0.04  # å¾0.05é™ä½åˆ°0.04
                    
                decay_multiplier = min(2.0, 1.0 + (trend_state['trend_decay_counter'][bet_type] * 0.05))  # ä¹˜æ•¸å¾0.08é™ä½åˆ°0.05
                decay_rate *= decay_multiplier
                
                if current_strength > 0:
                    trend_state['trend_strength'][bet_type] = max(0, current_strength - decay_rate)
                elif current_strength < 0:
                    trend_state['trend_strength'][bet_type] = min(0, current_strength + decay_rate)
            
            # ç´¯ç©è®ŠåŒ–ï¼ˆèˆ‡CPUç›¸åŒï¼‰- V2.1.1å„ªåŒ–
            cumulative_effect = current_change * 0.04  # å¾0.03å¢åŠ åˆ°0.04
            trend_state['cumulative_changes'][bet_type] += cumulative_effect
            trend_state['cumulative_changes'][bet_type] = max(-12.0, min(12.0, trend_state['cumulative_changes'][bet_type]))  # å¾8.0å¢åŠ åˆ°12.0
            
            # æ›´æ–°è®ŠåŒ–æ­·å²
            trend_state['change_history'][bet_type].append(current_change)
            if len(trend_state['change_history'][bet_type]) > 5:
                trend_state['change_history'][bet_type].pop(0)
        
        # æ›´æ–°é€£çºŒç„¡æ¨è–¦è¨ˆæ•¸
        if recommendation is None:
            trend_state['consecutive_no_recommendation'] += 1
        else:
            trend_state['consecutive_no_recommendation'] = 0
        
        # æ›´æ–°å…ˆå‰è®ŠåŒ–
        trend_state['previous_changes'] = current_changes

    def _generate_result_text(self, recommendation, winner, winner_chinese, is_reverse=False):
        """ç”Ÿæˆçµæœæ–‡æœ¬"""
        if recommendation:
            chinese_name = 'èŠ' if recommendation == 'banker' else 'é–’'
            result = 'âœ“' if recommendation == winner else 'âœ—âœ—'
            reverse_indicator = "ğŸ”„ğŸ”„" if is_reverse else ""
            return f"ï¼Œæ¨è–¦{reverse_indicator}({chinese_name})ï¼Œ{winner_chinese}è´ {result}"
        else:
            return "ï¼Œç„¡æ¨è–¦"

    def _calculate_changes(self, probabilities):
        """è¨ˆç®—è®ŠåŒ–ç‡ï¼ˆèˆ‡ä¸»ç¨‹å¼ç›¸åŒï¼‰"""
        changes = {}
        for key in probabilities:
            changes[key] = ((probabilities[key] - self.base_probabilities[key]) / self.base_probabilities[key]) * 100
        return changes

    def _cpu_fallback_simulation(self, num_simulations):
        """CPUå›é€€æ¨¡æ“¬"""
        print("ä½¿ç”¨CPUé€²è¡Œæ¨¡æ“¬...")
        start_time = time.time()
        
        results = {
            'banker_wins': 0,
            'player_wins': 0,
            'ties': 0,
            'detailed_results': []
        }
        
        # ä½¿ç”¨çµ±ä¸€çš„ç‰Œå †ç®¡ç†å’Œè¶¨å‹¢ç‹€æ…‹
        current_deck = self.initialize_deck_gpu()
        random.shuffle(current_deck)
        current_trend_state = self.trend_state
        
        for i in range(num_simulations):
            result = self._simulate_single_game_cpu(i, current_deck, current_trend_state)
            current_deck = result['remaining_deck']
            
            if result['winner'] == 'banker':
                results['banker_wins'] += 1
            elif result['winner'] == 'player':
                results['player_wins'] += 1
            else:
                results['ties'] += 1
            
            results['detailed_results'].append(result)
        
        total_games = num_simulations
        results['banker_win_rate'] = results['banker_wins'] / total_games * 100
        results['player_win_rate'] = results['player_wins'] / total_games * 100
        results['tie_rate'] = results['ties'] / total_games * 100
        
        end_time = time.time()
        results['performance'] = {
            'total_time': end_time - start_time,
            'games_per_second': num_simulations / (end_time - start_time),
            'batch_size': 1
        }
        
        return results

    def initialize_deck_gpu(self):
        """åˆå§‹åŒ–ç‰Œå †ï¼ˆèˆ‡ä¸»ç¨‹å¼ç›¸åŒï¼‰"""
        deck = []
        for _ in range(self.decks):
            for card in self.card_names:
                deck.extend([card] * 4)
        return deck

class BaccaratAIAssistant:
    def __init__(self, root):
        self.root = root
        self.root.title("ç™¾å®¶æ¨‚ AI ç®—ç‰Œé æ¸¬ v3.8.4 - GPU-DP-V2.1.1ï¼ˆé«˜æ¨è–¦ç‡å„ªåŒ–ç‰ˆï¼‰")
        self.root.geometry("1200x800")
        self.root.configure(bg='#1a1a1a')
        
        # GPU ç›¸é—œåˆå§‹åŒ–
        self.gpu_enabled = GPU_AVAILABLE
        self.gpu_simulator = None
        if self.gpu_enabled:
            try:
                self.gpu_simulator = BaccaratGPUSimulator()
                print("âœ“ GPUæ¨¡æ“¬å™¨åˆå§‹åŒ–æˆåŠŸ - v3.8.4é«˜æ¨è–¦ç‡å„ªåŒ–ç³»çµ±")
            except Exception as e:
                print(f"âœ—âœ— GPUæ¨¡æ“¬å™¨åˆå§‹åŒ–å¤±æ•—: {e}")
                self.gpu_enabled = False
        else:
            print("âœ—âœ— GPUä¸å¯ç”¨ï¼Œä½¿ç”¨CPUæ¨¡æ“¬")
        
        # åˆå§‹åŒ–æ•¸æ“š
        self.game_count = 1
        self.a_count = 0
        self.decks = 10
        self.simulation_running = False
        self.simulation_stop_flag = False
        self.export_path = os.getcwd()
        
        # è¶¨å‹¢åŠ é€Ÿç›¸é—œè®Šé‡ï¼ˆèˆ‡GPUæ¨¡æ“¬å™¨å®Œå…¨ä¸€è‡´ï¼‰- V2.1.1é«˜æ¨è–¦ç‡å„ªåŒ–åƒæ•¸
        self.previous_changes = {
            'banker': 0.0,
            'player': 0.0, 
            'tie': 0.0
        }
        self.trend_strength = {
            'banker': 0.0,
            'player': 0.0,
            'tie': 0.0
        }
        self.consecutive_no_recommendation = 0
        
        # è¶¨å‹¢éæ¿¾åƒæ•¸ - V2.1.1å¤§å¹…å„ªåŒ–ï¼ˆé«˜æ¨è–¦ç‡ï¼‰
        self.trend_filter_enabled = True
        self.min_trend_strength = 0.0001  # å¾0.01å¤§å¹…é™ä½åˆ°0.0001
        self.acceleration_threshold = 0.01  # å¾0.05é™ä½åˆ°0.01
        self.max_trend_strength = 25.0  # å¾15.0å¢åŠ åˆ°25.0
        
        # ç´¯ç©è®ŠåŒ–ç‡ç³»çµ±ï¼ˆèˆ‡GPUæ¨¡æ“¬å™¨ä¸€è‡´ï¼‰- V2.1.1å¤§å¹…æ”¾å¯¬
        self.cumulative_changes = {
            'banker': 0.0,
            'player': 0.0,
            'tie': 0.0
        }
        self.max_cumulative_change = 12.0  # å¾8.0å¢åŠ åˆ°12.0
        self.change_history = {
            'banker': [],
            'player': [],
            'tie': []
        }
        
        # è¶¨å‹¢å¼·åº¦è¡°æ¸›è¨ˆæ•¸å™¨ï¼ˆèˆ‡GPUæ¨¡æ“¬å™¨ä¸€è‡´ï¼‰- V2.1.1å„ªåŒ–
        self.trend_decay_counter = {
            'banker': 0,
            'player': 0,
            'tie': 0
        }
        self.base_decay_rate = 0.02  # å¾0.03é™ä½åˆ°0.02
        
        self.current_cards = []
        self.manual_threshold_set = False
        
        # ç­–ç•¥åƒæ•¸ - å°ˆæ³¨èŠé–’
        self.observe_bp = True
        self.observe_tie = False
        self.observe_pair = False
        self.observe_big_small = False
        
        # æ¨è–¦é–¾é–¾å€¼åƒæ•¸
        self.THRESHOLD_min_games = 1
        self.THRESHOLD_max_games = 100
        self.threshold_group = "standard"
        
        # åŸºç¤æ¦‚ç‡
        self.base_probabilities = {
            'banker': 45.851,
            'player': 44.695,
            'tie': 9.454,
            'banker_pair': 14.642,
            'player_pair': 14.642,
            'big': 62.113,
            'small': 37.887,
            'lucky_six': 8.331
        }
        
        # è³ ç‡è¨­å®š
        self.payouts = {
            'banker': 0.95,
            'player': 1.0,
            'tie': 8.0,
            'banker_pair': 11.0,
            'player_pair': 11.0,
            'big': 1.5,
            'small': 1.5,
            'lucky_six': 12.0
        }
        
        self.current_probs = self.base_probabilities.copy()
        self.history = []
        self.card_count = defaultdict(int)
        self.remaining_deck = self.initialize_deck(self.decks)
        
        self.recommendation_stats = {
            'banker': {'bet': 0, 'win': 0, 'amount': 0},
            'player': {'bet': 0, 'win': 0, 'amount': 0},
            'tie': {'bet': 0, 'win': 0, 'amount': 0}
        }
        
        self.current_result = ""
        self.current_recommendation_snapshot = None
        self.auto_sim_results = []
        
        # GPUæ¨¡æ“¬çµæœå­˜å„²
        self.gpu_simulation_history = []
        self.gpu_detailed_results = []
        
        # é«˜æ¨è–¦ç‡æ¨¡å¼æ¨™èªŒ
        self.high_recommendation_mode = True
        
        self.setup_ui()
        self.update_probabilities_display_only()

    def enable_high_recommendation_mode(self):
        """å•Ÿç”¨é«˜æ¨è–¦ç‡æ¨¡å¼ - V2.1.1æ ¸å¿ƒåŠŸèƒ½"""
        self.min_trend_strength = 0.0001
        self.acceleration_threshold = 0.005  # æ¥µä½é–¾å€¼
        self.max_trend_strength = 30.0
        player_drew = False
        player_third_card_value = None
        
        # ç©å®¶æŠ½ç‰Œè¦å‰‡ï¼ˆèˆ‡ä¸»ç¨‹å¼ç›¸åŒï¼‰
        if player_score <= 5:
            if len(deck) > 0:
                player_third_card = deck.pop(0)
                player_hand.append(player_third_card)
                player_score = sum(self.card_values[card] for card in player_hand) % 10
                player_drew = True
                player_third_card_value = self.card_values[player_third_card]
        
        # èŠå®¶æŠ½ç‰Œè¦å‰‡ï¼ˆèˆ‡ä¸»ç¨‹å¼ç›¸åŒï¼‰
        if banker_score <= 2:
            if len(deck) > 0:
                banker_third_card = deck.pop(0)
                banker_hand.append(banker_third_card)
                banker_score = sum(self.card_values[card] for card in banker_hand) % 10
        elif banker_score == 3 and player_drew and player_third_card_value != 8:
            if len(deck) > 0:
                banker_third_card = deck.pop(0)
                banker_hand.append(banker_third_card)
                banker_score = sum(self.card_values[card] for card in banker_hand) % 10
        elif banker_score == 4 and player_drew and player_third_card_value in [2,3,4,5,6,7]:
            if len(deck) > 0:
                banker_third_card = deck.pop(0)
                banker_hand.append(banker_third_card)
                banker_score = sum(self.card_values[card] for card in banker_hand) % 10
        elif banker_score == 5 and player_drew and player_third_card_value in [4,5,6,7]:
            if len(deck) > 0:
                banker_third_card = deck.pop(0)
                banker_hand.append(banker_third_card)
                banker_score = sum(self.card_values[card] for card in banker_hand) % 10
        elif banker_score == 6 and player_drew and player_third_card_value in [6,7]:
            if len(deck) > 0:
                banker_third_card = deck.pop(0)
                banker_hand.append(banker_third_card)
                banker_score = sum(self.card_values[card] for card in banker_hand) % 10
        
        # è¨ˆç®—å‹è² 
        if banker_score > player_score:
            winner = 'banker'
            winner_chinese = 'èŠ'
        elif player_score > banker_score:
            winner = 'player'
            winner_chinese = 'é–’'
        else:
            winner = 'tie'
            winner_chinese = 'å’Œ'
        
        # è¨ˆç®—çœŸå¯¦æ¦‚ç‡ï¼ˆèˆ‡CPUç›¸åŒï¼‰
        probabilities = self._calculate_probabilities_from_deck(deck)
        
        # ä½¿ç”¨å®Œå…¨ç›¸åŒçš„æ¨è–¦é‚è¼¯ï¼ˆåŒ…å«ç²¾æº–åå‘é‚è¼¯ï¼‰
        recommendation, bet_level, is_reverse = self._get_recommendation_with_main_logic(
            probabilities, 
            trend_state
        )
        
        # æ›´æ–°è¶¨å‹¢ç‹€æ…‹ï¼ˆèˆ‡CPUç›¸åŒï¼‰
        self._update_trend_state(trend_state, probabilities, recommendation)
        
        # ç”Ÿæˆçµæœ
        result_text = self._generate_result_text(recommendation, winner, winner_chinese, is_reverse)
        
        return {
            'game_id': game_id,
            'banker_hand': banker_hand,
            'player_hand': player_hand,
            'banker_score': banker_score,
            'player_score': player_score,
            'winner': winner,
            'winner_chinese': winner_chinese,
            'probabilities': probabilities,
            'recommendation': recommendation,
            'bet_level': bet_level,
            'is_reverse': is_reverse,
            'result_text': result_text,
            'result': 'âœ“' if recommendation == winner else 'âœ—âœ—' if recommendation else 'ç„¡',
            'remaining_deck': deck,
            'changes': self._calculate_changes(probabilities),
            'trend_state': trend_state
        }

    def _calculate_probabilities_from_deck(self, deck):
        """è¨ˆç®—åŸºæ–¼å‰©é¤˜ç‰Œå †çš„çœŸå¯¦æ¦‚ç‡ï¼ˆèˆ‡ä¸»ç¨‹å¼å®Œå…¨ä¸€è‡´ï¼‰"""
        total_cards = len(deck)
        total_initial_cards = self.decks * 52
        
        if total_cards < 20:  # èˆ‡ä¸»ç¨‹å¼ç›¸åŒçš„é‡æ–°æ´—ç‰Œæ¢ä»¶
            return self.base_probabilities.copy()
        
        # è¨ˆç®—å„é»æ•¸ç‰Œçš„æ•¸é‡ï¼ˆèˆ‡ä¸»ç¨‹å¼ç›¸åŒï¼‰
        card_counts = {}
        for card in self.card_names:
            count = deck.count(card)
            card_counts[card] = count
        
        point_ratios = {}
        for point in range(0, 10):
            if point == 0:
                cards_for_point = ['10', 'J', 'Q', 'K']
            else:
                cards_for_point = [card for card in self.card_names if self.card_values[card] == point]
            
            total_count = sum(card_counts[card] for card in cards_for_point)
            point_ratios[point] = total_count / total_cards
        
        # èˆ‡ä¸»ç¨‹å¼å®Œå…¨ç›¸åŒçš„èª¿æ•´å…¬å¼
        high_card_ratio = point_ratios[0]
        low_card_ratio = sum(point_ratios[i] for i in [1, 2, 3, 4, 5])
        medium_card_ratio = sum(point_ratios[i] for i in [6, 7])
        eight_nine_ratio = sum(point_ratios[i] for i in [8, 9])
        
        banker_adjust = (eight_nine_ratio - 0.158) * 8 - (low_card_ratio - 0.385) * 4
        player_adjust = (low_card_ratio - 0.385) * 8 - (eight_nine_ratio - 0.158) * 4
        tie_adjust = (medium_card_ratio - 0.308) * 6
        
        # æ¶ˆè€—æ•ˆæ‡‰ï¼ˆèˆ‡ä¸»ç¨‹å¼ç›¸åŒï¼‰
        consumption_ratio = (total_initial_cards - total_cards) / total_initial_cards
        consumption_effect = consumption_ratio * 2
        
        # èˆ‡ä¸»ç¨‹å¼ç›¸åŒçš„æ¦‚ç‡è¨ˆç®—
        probabilities = {
            'banker': max(40.0, min(52.0, self.base_probabilities['banker'] + banker_adjust + consumption_effect)),
            'player': max(40.0, min(52.0, self.base_probabilities['player'] + player_adjust - consumption_effect)),
            'tie': max(5.0, min(15.0, self.base_probabilities['tie'] + tie_adjust))
        }
        
        # æ­£è¦åŒ–ï¼ˆèˆ‡ä¸»ç¨‹å¼ç›¸åŒï¼‰
        total = sum(probabilities.values())
        if total > 0:
            scale = 100.0 / total
            for key in probabilities:
                probabilities[key] = round(probabilities[key] * scale, 3)
        
        return probabilities

    def _get_recommendation_with_main_logic(self, probabilities, trend_state):
        """å®Œå…¨è¤‡è£½ä¸»ç¨‹å¼çš„æ¨è–¦é‚è¼¯ï¼ˆåŒ…å«ç²¾æº–åå‘é‚è¼¯ï¼‰"""
        banker_prob = probabilities['banker']
        player_prob = probabilities['player']
        
        # è¨ˆç®—è®ŠåŒ–ç‡ï¼ˆèˆ‡ä¸»ç¨‹å¼å®Œå…¨ç›¸åŒï¼‰
        base_probs = self.base_probabilities
        banker_change = ((banker_prob - base_probs['banker']) / base_probs['banker']) * 100
        player_change = ((player_prob - base_probs['player']) / base_probs['player']) * 100
        
        # è¨ˆç®—åŠ é€Ÿï¼ˆèˆ‡ä¸»ç¨‹å¼å®Œå…¨ç›¸åŒï¼‰
        previous_changes = trend_state['previous_changes']
        banker_acceleration = banker_change - previous_changes['banker']
        player_acceleration = player_change - previous_changes['player']
        
        # èŠå®¶æ¨è–¦åˆ¤æ–·ï¼ˆå®Œå…¨è¤‡è£½ä¸»ç¨‹å¼é‚è¼¯ + ç²¾æº–åå‘é‚è¼¯ï¼‰
        banker_recommendation = self._evaluate_bet_recommendation(
            'banker', banker_prob, banker_change, banker_acceleration, trend_state
        )
        
        # é–’å®¶æ¨è–¦åˆ¤æ–·ï¼ˆå®Œå…¨è¤‡è£½ä¸»ç¨‹å¼é‚è¼¯ + ç²¾æº–åå‘é‚è¼¯ï¼‰
        player_recommendation = self._evaluate_bet_recommendation(
            'player', player_prob, player_change, player_acceleration, trend_state
        )
        
        # é¸æ“‡æœ€ä½³æ¨è–¦ï¼ˆèˆ‡ä¸»ç¨‹å¼ç›¸åŒï¼‰
        recommendations = []
        if banker_recommendation and banker_recommendation['level'] > 0:
            recommendations.append(banker_recommendation)
        if player_recommendation and player_recommendation['level'] > 0:
            recommendations.append(player_recommendation)
        
        if recommendations:
            recommendations.sort(key=lambda x: (x['level'], abs(trend_state['trend_strength'][x['bet_type']])), reverse=True)
            best_rec = recommendations[0]
            return best_rec['bet_type'], best_rec['level'], best_rec.get('is_reverse', False)
        else:
            return None, 0, False

    def _evaluate_bet_recommendation(self, bet_type, current_prob, percentage_change, acceleration, trend_state):
        """è©•ä¼°ä¸‹æ³¨æ¨è–¦ï¼ˆå®Œå…¨è¤‡è£½ä¸»ç¨‹å¼é‚è¼¯ + ç²¾æº–åå‘é‚è¼¯ï¼‰- V2.1.1é«˜æ¨è–¦ç‡å„ªåŒ–"""
        if bet_type not in thresholds_dict:
            return None
        
        # å‹•æ…‹åŠ é€Ÿé–¾é–¾å€¼ï¼ˆèˆ‡ä¸»ç¨‹å¼ç›¸åŒï¼‰- V2.1.1å„ªåŒ–
        base_threshold = 0.01  # å¾0.05é™ä½åˆ°0.01ï¼ˆé«˜æ¨è–¦ç‡å„ªåŒ–ï¼‰
        consecutive_no_recommendation = trend_state['consecutive_no_recommendation']
        
        if consecutive_no_recommendation >= 15:  # å¾10å¢åŠ åˆ°15ï¼ˆæ”¾å¯¬æ‡²ç½°ï¼‰
            current_accel_threshold = base_threshold * 0.8  # å¾0.5å¢åŠ åˆ°0.8
        elif consecutive_no_recommendation >= 10:  # å¾6å¢åŠ åˆ°10
            current_accel_threshold = base_threshold * 0.9  # å¾0.7å¢åŠ åˆ°0.9
        elif consecutive_no_recommendation >= 5:   # å¾3å¢åŠ åˆ°5
            current_accel_threshold = base_threshold * 0.95  # å¾0.85å¢åŠ åˆ°0.95
        else:
            current_accel_threshold = base_threshold
        
        # è¶¨å‹¢éæ¿¾ï¼ˆèˆ‡ä¸»ç¨‹å¼ç›¸åŒï¼‰- V2.1.1å¤§å¹…æ”¾å¯¬
        if abs(trend_state['trend_strength'][bet_type]) < 0.0001:  # å¾0.0001ä¿æŒä¸è®Š
            return None
        
        final_bet_type = bet_type
        cumulative_bonus = 0
        is_reverse = False
        
        # V2.1.1å„ªåŒ–ï¼šå¤§å¹…é™ä½ç´¯ç©è®ŠåŒ–çå‹µé–€æª»
        if abs(trend_state['cumulative_changes'][bet_type]) > 0.3:  # å¾0.5é™ä½åˆ°0.3
            cumulative_bonus = min(3, int(abs(trend_state['cumulative_changes'][bet_type]) * 3))  # çå‹µå¢åŠ 
        
        # é¦–å…ˆæª¢æŸ¥ç²¾æº–åå‘é‚è¼¯
        reverse_bet, reverse_level = improved_reverse_evaluation(
            bet_type, current_prob, percentage_change, acceleration, 
            trend_state, reverse_thresholds_dict[bet_type].get("reverse_1", {})
        )
        
        if reverse_bet and reverse_level > 0:
            final_bet_type = reverse_bet
            base_level = reverse_level
            is_reverse = True
        else:
            # åŸæœ‰é–¾é–¾å€¼åˆ¤æ–·é‚è¼¯ï¼ˆèˆ‡ä¸»ç¨‹å¼å®Œå…¨ç›¸åŒï¼‰- V2.1.1æ–°å¢å¯¬é¬†ç´šåˆ¥
            for level in ['7', '6', '5', '4', '3', '2', '1', '0']:  # æ–°å¢'0'ç´šåˆ¥
                if level in thresholds_dict[bet_type]:
                    threshold = thresholds_dict[bet_type][level]
                    
                    if current_prob < threshold.get("min_prob", 0):
                        continue
                    
                    if (threshold["min_change"] <= abs(percentage_change) < threshold["max_change"] and 
                        acceleration >= threshold["min_accel"]):
                        
                        base_level = threshold["level"]
                        
                        if threshold.get("reverse", False) or threshold.get("win_rate", 50) < 49:
                            final_bet_type = 'player' if bet_type == 'banker' else 'banker'
                            base_level = 1
                            is_reverse = True
                        
                        if not threshold.get("reverse", False) and threshold.get("win_rate", 50) >= 49:
                            final_level = min(20, base_level + cumulative_bonus)
                        else:
                            final_level = base_level
                        
                        return {
                            'bet_type': final_bet_type,
                            'level': final_level,
                            'is_reverse': is_reverse
                        }
            
            return None
        
        # åå‘é‚è¼¯çš„ç­‰ç´šè¨ˆç®—
        if is_reverse:
            reverse_level_adjusted = get_reverse_bet_level(
                bet_type, current_prob, percentage_change, acceleration, trend_state
            )
            final_level = max(1, min(5, base_level + reverse_level_adjusted))
            
            return {
                'bet_type': final_bet_type,
                'level': final_level,
                'is_reverse': is_reverse
            }
        
        return None

    def _update_trend_state(self, trend_state, probabilities, recommendation):
        """æ›´æ–°è¶¨å‹¢ç‹€æ…‹ï¼ˆèˆ‡ä¸»ç¨‹å¼å®Œå…¨ç›¸åŒï¼‰- V2.1.1é«˜æ¨è–¦ç‡å„ªåŒ–"""
        # è¨ˆç®—è®ŠåŒ–ç‡
        current_changes = {}
        for bet_type in ['banker', 'player', 'tie']:
            current_prob = probabilities[bet_type]
            base_prob = self.base_probabilities[bet_type]
            current_changes[bet_type] = ((current_prob - base_prob) / base_prob) * 100
        
        # æ›´æ–°è¶¨å‹¢å¼·åº¦ï¼ˆèˆ‡ä¸»ç¨‹å¼ç›¸åŒçš„è¤‡é›œé‚è¼¯ï¼‰- V2.1.1å„ªåŒ–
        for bet_type in ['banker', 'player']:
            current_change = current_changes[bet_type]
            previous_change = trend_state['previous_changes'][bet_type]
            acceleration = current_change - previous_change
            
            # å®Œå…¨è¤‡è£½CPUçš„è¶¨å‹¢æ›´æ–°é‚è¼¯ - V2.1.1å¤§å¹…å„ªåŒ–
            current_strength = trend_state['trend_strength'][bet_type]
            
            # V2.1.1å„ªåŒ–ï¼šå¤§å¹…é™ä½åŠ é€Ÿè§¸ç™¼é–€æª»
            if acceleration > 0.01:  # åŠ é€Ÿé–¾é–¾å€¼å¾0.05é™ä½åˆ°0.01
                strength_increment = max(0.02, min(3.0, abs(acceleration) * 0.8))  # ä¹˜æ•¸å¾0.5å¢åŠ åˆ°0.8
                if current_strength > 12.0:  # å¾8.0å¢åŠ åˆ°12.0
                    strength_increment *= 0.8  # å¾0.6å¢åŠ åˆ°0.8
                elif current_strength > 8.0:   # å¾5.0å¢åŠ åˆ°8.0
                    strength_increment *= 0.9  # å¾0.8å¢åŠ åˆ°0.9
                trend_state['trend_strength'][bet_type] = min(25.0, current_strength + strength_increment)  # å¾15.0å¢åŠ åˆ°25.0
                trend_state['trend_decay_counter'][bet_type] = 0
            elif acceleration < -0.01:  # åŠ é€Ÿé–¾é–¾å€¼å¾0.05é™ä½åˆ°0.01
                strength_decrement = max(0.02, min(3.0, abs(acceleration) * 0.8))  # ä¹˜æ•¸å¾0.5å¢åŠ åˆ°0.8
                trend_state['trend_strength'][bet_type] = max(-25.0, current_strength - strength_decrement)  # å¾15.0å¢åŠ åˆ°25.0
                trend_state['trend_decay_counter'][bet_type] = 0
            else:
                trend_state['trend_decay_counter'][bet_type] += 1
                
                # è¡°æ¸›é‚è¼¯ï¼ˆèˆ‡CPUç›¸åŒï¼‰- V2.1.1å„ªåŒ–
                decay_rate = 0.02  # å¾0.03é™ä½åˆ°0.02
                if abs(current_strength) > 15.0:  # å¾10.0å¢åŠ åˆ°15.0
                    decay_rate = 0.10  # å¾0.12é™ä½åˆ°0.10
                elif abs(current_strength) > 10.0:  # å¾6.0å¢åŠ åˆ°10.0
                    decay_rate = 0.06  # å¾0.08é™ä½åˆ°0.06
                elif abs(current_strength) > 5.0:   # å¾3.0å¢åŠ åˆ°5.0
                    decay_rate = 0.04  # å¾0.05é™ä½åˆ°0.04
                    
                decay_multiplier = min(2.0, 1.0 + (trend_state['trend_decay_counter'][bet_type] * 0.05))  # ä¹˜æ•¸å¾0.08é™ä½åˆ°0.05
                decay_rate *= decay_multiplier
                
                if current_strength > 0:
                    trend_state['trend_strength'][bet_type] = max(0, current_strength - decay_rate)
                elif current_strength < 0:
                    trend_state['trend_strength'][bet_type] = min(0, current_strength + decay_rate)
            
            # ç´¯ç©è®ŠåŒ–ï¼ˆèˆ‡CPUç›¸åŒï¼‰- V2.1.1å„ªåŒ–
            cumulative_effect = current_change * 0.04  # å¾0.03å¢åŠ åˆ°0.04
            trend_state['cumulative_changes'][bet_type] += cumulative_effect
            trend_state['cumulative_changes'][bet_type] = max(-12.0, min(12.0, trend_state['cumulative_changes'][bet_type]))  # å¾8.0å¢åŠ åˆ°12.0
            
            # æ›´æ–°è®ŠåŒ–æ­·å²
            trend_state['change_history'][bet_type].append(current_change)
            if len(trend_state['change_history'][bet_type]) > 5:
                trend_state['change_history'][bet_type].pop(0)
        
        # æ›´æ–°é€£çºŒç„¡æ¨è–¦è¨ˆæ•¸
        if recommendation is None:
            trend_state['consecutive_no_recommendation'] += 1
        else:
            trend_state['consecutive_no_recommendation'] = 0
        
        # æ›´æ–°å…ˆå‰è®ŠåŒ–
        trend_state['previous_changes'] = current_changes

    def _generate_result_text(self, recommendation, winner, winner_chinese, is_reverse=False):
        """ç”Ÿæˆçµæœæ–‡æœ¬"""
        if recommendation:
            chinese_name = 'èŠ' if recommendation == 'banker' else 'é–’'
            result = 'âœ“' if recommendation == winner else 'âœ—âœ—'
            reverse_indicator = "ğŸ”„ğŸ”„" if is_reverse else ""
            return f"ï¼Œæ¨è–¦{reverse_indicator}({chinese_name})ï¼Œ{winner_chinese}è´ {result}"
        else:
            return "ï¼Œç„¡æ¨è–¦"

    def _calculate_changes(self, probabilities):
        """è¨ˆç®—è®ŠåŒ–ç‡ï¼ˆèˆ‡ä¸»ç¨‹å¼ç›¸åŒï¼‰"""
        changes = {}
        for key in probabilities:
            changes[key] = ((probabilities[key] - self.base_probabilities[key]) / self.base_probabilities[key]) * 100
        return changes

    def _cpu_fallback_simulation(self, num_simulations):
        """CPUå›é€€æ¨¡æ“¬"""
        print("ä½¿ç”¨CPUé€²è¡Œæ¨¡æ“¬...")
        start_time = time.time()
        
        results = {
            'banker_wins': 0,
            'player_wins': 0,
            'ties': 0,
            'detailed_results': []
        }
        
        # ä½¿ç”¨çµ±ä¸€çš„ç‰Œå †ç®¡ç†å’Œè¶¨å‹¢ç‹€æ…‹
        current_deck = self.initialize_deck_gpu()
        random.shuffle(current_deck)
        current_trend_state = self.trend_state
        
        for i in range(num_simulations):
            result = self._simulate_single_game_cpu(i, current_deck, current_trend_state)
            current_deck = result['remaining_deck']
            
            if result['winner'] == 'banker':
                results['banker_wins'] += 1
            elif result['winner'] == 'player':
                results['player_wins'] += 1
            else:
                results['ties'] += 1
            
            results['detailed_results'].append(result)
        
        total_games = num_simulations
        results['banker_win_rate'] = results['banker_wins'] / total_games * 100
        results['player_win_rate'] = results['player_wins'] / total_games * 100
        results['tie_rate'] = results['ties'] / total_games * 100
        
        end_time = time.time()
        results['performance'] = {
            'total_time': end_time - start_time,
            'games_per_second': num_simulations / (end_time - start_time),
            'batch_size': 1
        }
        
        return results

    def initialize_deck_gpu(self):
        """åˆå§‹åŒ–ç‰Œå †ï¼ˆèˆ‡ä¸»ç¨‹å¼ç›¸åŒï¼‰"""
        deck = []
        for _ in range(self.decks):
            for card in self.card_names:
                deck.extend([card] * 4)
        return deck

class BaccaratAIAssistant:
    def __init__(self, root):
        self.root = root
        self.root.title("ç™¾å®¶æ¨‚ AI ç®—ç‰Œé æ¸¬ v3.8.4 - GPU-DP-V2.1.1ï¼ˆé«˜æ¨è–¦ç‡å„ªåŒ–ç‰ˆï¼‰")
        self.root.geometry("1200x800")
        self.root.configure(bg='#1a1a1a')
        
        # GPU ç›¸é—œåˆå§‹åŒ–
        self.gpu_enabled = GPU_AVAILABLE
        self.gpu_simulator = None
        if self.gpu_enabled:
            try:
                self.gpu_simulator = BaccaratGPUSimulator()
                print("âœ“ GPUæ¨¡æ“¬å™¨åˆå§‹åŒ–æˆåŠŸ - v3.8.4é«˜æ¨è–¦ç‡å„ªåŒ–ç³»çµ±")
            except Exception as e:
                print(f"âœ—âœ— GPUæ¨¡æ“¬å™¨åˆå§‹åŒ–å¤±æ•—: {e}")
                self.gpu_enabled = False
        else:
            print("âœ—âœ— GPUä¸å¯ç”¨ï¼Œä½¿ç”¨CPUæ¨¡æ“¬")
        
        # åˆå§‹åŒ–æ•¸æ“š
        self.game_count = 1
        self.a_count = 0
        self.decks = 10
        self.simulation_running = False
        self.simulation_stop_flag = False
        self.export_path = os.getcwd()
        
        # è¶¨å‹¢åŠ é€Ÿç›¸é—œè®Šé‡ï¼ˆèˆ‡GPUæ¨¡æ“¬å™¨å®Œå…¨ä¸€è‡´ï¼‰- V2.1.1é«˜æ¨è–¦ç‡å„ªåŒ–åƒæ•¸
        self.previous_changes = {
            'banker': 0.0,
            'player': 0.0, 
            'tie': 0.0
        }
        self.trend_strength = {
            'banker': 0.0,
            'player': 0.0,
            'tie': 0.0
        }
        self.consecutive_no_recommendation = 0
        
        # è¶¨å‹¢éæ¿¾åƒæ•¸ - V2.1.1å¤§å¹…å„ªåŒ–ï¼ˆé«˜æ¨è–¦ç‡ï¼‰
        self.trend_filter_enabled = True
        self.min_trend_strength = 0.0001  # å¾0.01å¤§å¹…é™ä½åˆ°0.0001
        self.acceleration_threshold = 0.01  # å¾0.05é™ä½åˆ°0.01
        self.max_trend_strength = 25.0  # å¾15.0å¢åŠ åˆ°25.0
        
        # ç´¯ç©è®ŠåŒ–ç‡ç³»çµ±ï¼ˆèˆ‡GPUæ¨¡æ“¬å™¨ä¸€è‡´ï¼‰- V2.1.1å¤§å¹…æ”¾å¯¬
        self.cumulative_changes = {
            'banker': 0.0,
            'player': 0.0,
            'tie': 0.0
        }
        self.max_cumulative_change = 12.0  # å¾8.0å¢åŠ åˆ°12.0
        self.change_history = {
            'banker': [],
            'player': [],
            'tie': []
        }
        
        # è¶¨å‹¢å¼·åº¦è¡°æ¸›è¨ˆæ•¸å™¨ï¼ˆèˆ‡GPUæ¨¡æ“¬å™¨ä¸€è‡´ï¼‰- V2.1.1å„ªåŒ–
        self.trend_decay_counter = {
            'banker': 0,
            'player': 0,
            'tie': 0
        }
        self.base_decay_rate = 0.02  # å¾0.03é™ä½åˆ°0.02
        
        self.current_cards = []
        self.manual_threshold_set = False
        
        # ç­–ç•¥åƒæ•¸ - å°ˆæ³¨èŠé–’
        self.observe_bp = True
        self.observe_tie = False
        self.observe_pair = False
        self.observe_big_small = False
        
        # æ¨è–¦é–¾é–¾å€¼åƒæ•¸
        self.THRESHOLD_min_games = 1
        self.THRESHOLD_max_games = 100
        self.threshold_group = "standard"
        
        # åŸºç¤æ¦‚ç‡
        self.base_probabilities = {
            'banker': 45.851,
            'player': 44.695,
            'tie': 9.454,
            'banker_pair': 14.642,
            'player_pair': 14.642,
            'big': 62.113,
            'small': 37.887,
            'lucky_six': 8.331
        }
        
        # è³ ç‡è¨­å®š
        self.payouts = {
            'banker': 0.95,
            'player': 1.0,
            'tie': 8.0,
            'banker_pair': 11.0,
            'player_pair': 11.0,
            'big': 1.5,
            'small': 1.5,
            'lucky_six': 12.0
        }
        
        self.current_probs = self.base_probabilities.copy()
        self.history = []
        self.card_count = defaultdict(int)
        self.remaining_deck = self.initialize_deck(self.decks)
        
        self.recommendation_stats = {
            'banker': {'bet': 0, 'win': 0, 'amount': 0},
            'player': {'bet': 0, 'win': 0, 'amount': 0},
            'tie': {'bet': 0, 'win': 0, 'amount': 0}
        }
        
        self.current_result = ""
        self.current_recommendation_snapshot = None
        self.auto_sim_results = []
        
        # GPUæ¨¡æ“¬çµæœå­˜å„²
        self.gpu_simulation_history = []
        self.gpu_detailed_results = []
        
        # é«˜æ¨è–¦ç‡æ¨¡å¼æ¨™èªŒ
        self.high_recommendation_mode = True
        
        self.setup_ui()
        self.update_probabilities_display_only()

    def enable_high_recommendation_mode(self):
        """å•Ÿç”¨é«˜æ¨è–¦ç‡æ¨¡å¼ - V2.1.1æ ¸å¿ƒåŠŸèƒ½"""
        self.min_trend_strength = 0.0001
        self.acceleration_threshold = 0.005  # æ¥µä½é–¾å€¼
        self.max_trend_strength = 30.0
        self.max_cumulative_change = 15.0
        self.base_decay_rate = 0.01
        
        # ç¦ç”¨é€£çºŒç„¡æ¨è–¦æ‡²ç½°
        self.consecutive_no_recommendation = 0
        
        print("âœ… é«˜æ¨è–¦ç‡æ¨¡å¼å·²å•Ÿç”¨ - ç›®æ¨™æ¨è–¦ç‡: 45-65%")
        
    # GPU åŠ é€Ÿç›¸é—œæ–¹æ³•
    def start_gpu_simulation(self, num_simulations=10000):
        """å•Ÿå‹•GPUå¤§è¦æ¨¡æ¨¡æ“¬ - v3.8.4 é«˜æ¨è–¦ç‡å„ªåŒ–ç‰ˆæœ¬"""
        if not self.gpu_enabled:
            messagebox.showwarning("GPUä¸å¯ç”¨", "GPUåŠ é€Ÿä¸å¯ç”¨ï¼Œå°‡ä½¿ç”¨CPUæ¨¡æ“¬")
            return self.start_auto_simulate()
        
        if self.simulation_running:
            return
            
        self.simulation_running = True
        self.simulation_stop_flag = False
        
        self.data_status_label.config(text=f"GPUå¤§è¦æ¨¡æ¨¡æ“¬ä¸­... 0/{num_simulations}", fg='#ff00ff')
        
        def gpu_simulation_thread():
            try:
                start_time = time.time()
                
                print(f"ğŸ®ğŸ® é–‹å§‹GPUæ¨¡æ“¬: {num_simulations}å±€ - ä½¿ç”¨v3.8.4é«˜æ¨è–¦ç‡å„ªåŒ–ç³»çµ±")
                results = self.gpu_simulator.mass_simulation(num_simulations)
                
                end_time = time.time()
                simulation_time = end_time - start_time
                
                self.root.after(0, lambda: self.process_gpu_results(
                    results, num_simulations, simulation_time
                ))
                
            except Exception as e:
                print(f"âŒâŒ GPUæ¨¡æ“¬éŒ¯èª¤: {e}")
                self.root.after(0, lambda: self.fallback_to_cpu_simulation(num_simulations))
        
        thread = threading.Thread(target=gpu_simulation_thread)
        thread.daemon = True
        thread.start()

    def process_gpu_results(self, results, num_simulations, simulation_time):
        """è™•ç†GPUæ¨¡æ“¬çµæœä¸¦æ•´åˆåˆ°æ­·å²æ•¸æ“š"""
        self.simulation_running = False
        
        gpu_sim_record = {
            'type': 'gpu_simulation',
            'timestamp': datetime.now(),
            'num_simulations': num_simulations,
            'simulation_time': simulation_time,
            'results': results,
            'performance': results.get('performance', {}),
            'detailed_results': results.get('detailed_results', [])
        }
        
        self.gpu_simulation_history.append(gpu_sim_record)
        self.gpu_detailed_results.extend(results.get('detailed_results', []))
        
        self.convert_gpu_to_standard_history(results, num_simulations)
        
        speed = num_simulations / simulation_time
        performance_info = f"GPUæ¨¡æ“¬å®Œæˆ: {num_simulations}å±€ | ç”¨æ™‚: {simulation_time:.2f}ç§’ | é€Ÿåº¦: {speed:.0f}å±€/ç§’"
        
        result_text = f"{performance_info}\n\n"
        result_text += f"èŠå®¶å‹: {results['banker_wins']}å±€ ({results['banker_win_rate']:.2f}%)\n"
        result_text += f"é–’å®¶å‹: {results['player_wins']}å±€ ({results['player_win_rate']:.2f}%)\n"
        result_text += f"å’Œå±€: {results['ties']}å±€ ({results['tie_rate']:.2f}%)\n\n"
        
        gpu_stats = self.calculate_gpu_recommendation_stats(results['detailed_results'])
        result_text += "=== æ¨è–¦é …ç›®çµ±è¨ˆ ===\n"
        total_bet = 0
        total_win = 0
        total_amount = 0
        reverse_count = 0
        
        for bet_type, stats in gpu_stats.items():
            if stats['bet'] > 0:
                win_rate = stats['win'] / stats['bet'] * 100 if stats['bet'] > 0 else 0
                chinese_name = self.get_chinese_name(bet_type)
                reverse_indicator = "ğŸ”„ğŸ”„" if stats.get('is_reverse', False) else ""
                result_text += f"æ¨è–¦{reverse_indicator}{chinese_name}: {stats['win']}/{stats['bet']} ({win_rate:.1f}%)ï¼Œæ·¨åˆ©: {stats['amount']:.2f}\n"
                total_bet += stats['bet']
                total_win += stats['win']
                total_amount += stats['amount']
                if stats.get('is_reverse', False):
                    reverse_count += stats['bet']
        
        if total_bet > 0:
            overall_win_rate = total_win / total_bet * 100
            reverse_rate = (reverse_count / total_bet) * 100 if total_bet > 0 else 0
            result_text += f"\nç¸½è¨ˆ: {total_win}/{total_bet} ({overall_win_rate:.1f}%)ï¼Œç¸½æ·¨åˆ©: {total_amount:.2f}\n"
            result_text += f"åå‘æ¨è–¦: {reverse_count}å±€ ({reverse_rate:.1f}%)\n"
        
        result_text += f"\nâœ“ GPUæ¨¡æ“¬æ•¸æ“šå·²æ•´åˆåˆ°æ­·å²è¨˜éŒ„ä¸­ï¼Œå…±{len(results['detailed_results'])}ç­†è©³ç´°è¨˜éŒ„"
        result_text += f"\nâœ“ ä½¿ç”¨v3.8.4é«˜æ¨è–¦ç‡å„ªåŒ–ç³»çµ± - æ¨è–¦ç‡å¤§å¹…æå‡"
        
        messagebox.showinfo("GPUæ¨¡æ“¬çµæœ v3.8.4", result_text)
        
        self.data_status_label.config(text=f"GPUæ¨¡æ“¬å®Œæˆ - {speed:.0f}å±€/ç§’ - é«˜æ¨è–¦ç‡ç³»çµ±", fg='#00ff00')
        
        self.update_recommendation_display()

    def calculate_gpu_recommendation_stats(self, detailed_results):
        """è¨ˆç®—GPUæ¨¡æ“¬çš„æ¨è–¦çµ±è¨ˆ"""
        stats = {
            'banker': {'bet': 0, 'win': 0, 'amount': 0, 'is_reverse': False},
            'player': {'bet': 0, 'win': 0, 'amount': 0, 'is_reverse': False},
            'tie': {'bet': 0, 'win': 0, 'amount': 0, 'is_reverse': False}
        }
        
        for result in detailed_results:
            bet_type = result.get('recommendation')
            bet_level = result.get('bet_level', 0)
            is_reverse = result.get('is_reverse', False)
            
            if bet_type and bet_level > 0:
                stats[bet_type]['bet'] += bet_level
                stats[bet_type]['is_reverse'] = is_reverse
                
                if result.get('result') == 'âœ“':
                    stats[bet_type]['win'] += bet_level
                    if bet_type == 'banker':
                        stats[bet_type]['amount'] += bet_level * 0.95
                    elif bet_type == 'player':
                        stats[bet_type]['amount'] += bet_level * 1.0
                    else:
                        stats[bet_type]['amount'] += bet_level * 7.0
                elif result.get('result') == 'âœ—âœ—':
                    stats[bet_type]['amount'] -= bet_level
        
        return stats

    def convert_gpu_to_standard_history(self, results, num_simulations):
        """å°‡GPUæ¨¡æ“¬çµæœè½‰æ›ç‚ºæ¨™æº–æ­·å²æ ¼å¼"""
        detailed_results = results.get('detailed_results', [])
        
        for i, gpu_result in enumerate(detailed_results):
            record = {
                'round': self.game_count + i,
                'type': 'gpu_simulated',
                'cards': [],
                'banker_hand': gpu_result.get('banker_hand', []),
                'player_hand': gpu_result.get('player_hand', []),
                'banker_score': gpu_result.get('banker_score', 0),
                'player_score': gpu_result.get('player_score', 0),
                'winner': gpu_result.get('winner', ''),
                'winner_chinese': gpu_result.get('winner_chinese', ''),
                'recommendation': gpu_result.get('recommendation'),
                'recommendation_chinese': self.get_chinese_name(gpu_result.get('recommendation', '')),
                'bet_level': gpu_result.get('bet_level', 0),
                'is_reverse': gpu_result.get('is_reverse', False),
                'probabilities': gpu_result.get('probabilities', self.base_probabilities.copy()),
                'recommendation_result': gpu_result.get('result_text', ''),
                'changes': gpu_result.get('changes', {}),
                'timestamp': datetime.now(),
                'simulation_id': i,
                'consistency_version': 'v3.8.4-HR'  # æ¨™è¨˜é«˜æ¨è–¦ç‡ç‰ˆæœ¬
            }
            
            self.history.append(record)
        
        self.game_count += len(detailed_results)

    def fallback_to_cpu_simulation(self, num_simulations):
        """å›é€€åˆ°CPUæ¨¡æ“¬"""
        messagebox.showinfo("åˆ‡æ›åˆ°CPU", "GPUæ¨¡æ“¬å¤±æ•—ï¼Œåˆ‡æ›åˆ°CPUæ¨¡æ“¬")
        self.start_auto_simulate()

    def calculate_acceleration(self, current_change, previous_change):
        """è¨ˆç®—è®ŠåŒ–ç‡åŠ é€Ÿï¼ˆç•¶å‰è®ŠåŒ–ç‡ - ä¸Šä¸€å±€è®ŠåŒ–ç‡ï¼‰"""
        return current_change - previous_change

    def update_trend_strength(self, bet_type, acceleration, percentage_change):
        """æ›´æ–°è¶¨å‹¢å¼·åº¦è¨ˆæ•¸å™¨ - v3.8.4é«˜æ¨è–¦ç‡å„ªåŒ–ç‰ˆæœ¬"""
        current_strength = self.trend_strength[bet_type]
        
        if acceleration > self.acceleration_threshold:  # 0.01
            strength_increment = max(0.02, min(3.0, abs(acceleration) * 0.8))  # ä¹˜æ•¸å¾0.5å¢åŠ åˆ°0.8
            
            # æ”¾å¯¬å¼·åº¦é™åˆ¶
            if current_strength > 12.0:  # å¾8.0å¢åŠ åˆ°12.0
                strength_increment *= 0.8  # å¾0.6å¢åŠ åˆ°0.8
            elif current_strength > 8.0:   # å¾5.0å¢åŠ åˆ°8.0
                strength_increment *= 0.9  # å¾0.8å¢åŠ åˆ°0.9
                
            new_strength = current_strength + strength_increment
            self.trend_strength[bet_type] = min(self.max_trend_strength, new_strength)
            self.trend_decay_counter[bet_type] = 0
            
        elif acceleration < -self.acceleration_threshold:
            strength_decrement = max(0.02, min(3.0, abs(acceleration) * 0.8))  # ä¹˜æ•¸å¾0.5å¢åŠ åˆ°0.8
            new_strength = current_strength - strength_decrement
            self.trend_strength[bet_type] = max(-self.max_trend_strength, new_strength)
            self.trend_decay_counter[bet_type] = 0
            
        else:
            self.trend_decay_counter[bet_type] += 1
            
            # é™ä½è¡°æ¸›ç‡
            decay_rate = self.base_decay_rate  # 0.02
            if abs(current_strength) > 15.0:  # å¾10.0å¢åŠ åˆ°15.0
                decay_rate = 0.10  # å¾0.12é™ä½åˆ°0.10
            elif abs(current_strength) > 10.0:  # å¾6.0å¢åŠ åˆ°10.0
                decay_rate = 0.06  # å¾0.08é™ä½åˆ°0.06
            elif abs(current_strength) > 5.0:   # å¾3.0å¢åŠ åˆ°5.0
                decay_rate = 0.04  # å¾0.05é™ä½åˆ°0.04
                
            decay_multiplier = min(2.0, 1.0 + (self.trend_decay_counter[bet_type] * 0.05))  # ä¹˜æ•¸å¾0.08é™ä½åˆ°0.05
            decay_rate *= decay_multiplier
            
            if current_strength > 0:
                self.trend_strength[bet_type] = max(0, current_strength - decay_rate)
            elif current_strength < 0:
                self.trend_strength[bet_type] = min(0, current_strength + decay_rate)
        
        # å¢åŠ ç´¯ç©è®ŠåŒ–æ•ˆæœ
        cumulative_effect = percentage_change * 0.04  # å¾0.03å¢åŠ åˆ°0.04
        self.cumulative_changes[bet_type] += cumulative_effect
        self.cumulative_changes[bet_type] = max(-self.max_cumulative_change, 
                                               min(self.max_cumulative_change, 
                                                   self.cumulative_changes[bet_type]))
        
        self.change_history[bet_type].append(percentage_change)
        if len(self.change_history[bet_type]) > 5:
            self.change_history[bet_type].pop(0)
        
        if len(self.change_history[bet_type]) >= 3:
            recent_changes = self.change_history[bet_type][-3:]
            if all(c > 0 for c in recent_changes) or all(c < 0 for c in recent_changes):
                pattern_bonus = 0.2
                if self.trend_strength[bet_type] > 0:
                    self.trend_strength[bet_type] = min(self.max_trend_strength, 
                                                       self.trend_strength[bet_type] + pattern_bonus)
                else:
                    self.trend_strength[bet_type] = max(-self.max_trend_strength, 
                                                       self.trend_strength[bet_type] - pattern_bonus)

    def get_dynamic_acceleration_threshold(self):
        """æ ¹æ“šé€£çºŒç„¡æ¨è–¦å±€æ•¸å‹•æ…‹èª¿æ•´åŠ é€Ÿé–¾é–¾å€¼ - v3.8.4é«˜æ¨è–¦ç‡å„ªåŒ–ç‰ˆæœ¬"""
        base_threshold = self.acceleration_threshold  # 0.01
        
        # å¤§å¹…æ¸›å°‘é€£çºŒç„¡æ¨è–¦çš„æ‡²ç½°
        if self.consecutive_no_recommendation >= 15:  # å¾10å¢åŠ åˆ°15
            return base_threshold * 0.8  # å¾0.5å¢åŠ åˆ°0.8
        elif self.consecutive_no_recommendation >= 10:  # å¾6å¢åŠ åˆ°10
            return base_threshold * 0.9  # å¾0.7å¢åŠ åˆ°0.9
        elif self.consecutive_no_recommendation >= 5:   # å¾3å¢åŠ åˆ°5
            return base_threshold * 0.95  # å¾0.85å¢åŠ åˆ°0.95
        else:
            return base_threshold

    def get_bet_recommendation(self, bet_type, percentage_change, acceleration):
        """æ ¹æ“šæ¦‚ç‡è®ŠåŒ–ç™¾åˆ†æ¯”å’ŒåŠ é€Ÿç²å–ä¸‹æ³¨æ¨è–¦ï¼ˆv3.8.4é«˜æ¨è–¦ç‡å„ªåŒ–ç‰ˆæœ¬ï¼‰"""
        if bet_type not in thresholds_dict:
            return 0, bet_type, False
        
        if bet_type == 'tie':
            return 0, bet_type, False
        
        current_accel_threshold = self.get_dynamic_acceleration_threshold()
        
        # å¤§å¹…é™ä½è¶¨å‹¢éæ¿¾é–¾é–¾å€¼
        if self.trend_filter_enabled and abs(self.trend_strength[bet_type]) < self.min_trend_strength:
            return 0, bet_type, False
        
        current_prob = self.current_probs[bet_type]
        final_bet_type = bet_type
        cumulative_bonus = 0
        is_reverse = False
        
        # å¤§å¹…æ”¾å¯¬ç´¯ç©è®ŠåŒ–çå‹µé–€æª»
        if abs(self.cumulative_changes[bet_type]) > 0.3:  # å¾0.5é™ä½åˆ°0.3
            cumulative_bonus = min(3, int(abs(self.cumulative_changes[bet_type]) * 3))  # çå‹µåŠ å€
        
        # é¦–å…ˆæª¢æŸ¥ç²¾æº–åå‘é‚è¼¯
        reverse_bet, reverse_level = improved_reverse_evaluation(
            bet_type, current_prob, percentage_change, acceleration, 
            {
                'trend_strength': self.trend_strength,
                'cumulative_changes': self.cumulative_changes,
                'change_history': self.change_history
            }, 
            reverse_thresholds_dict[bet_type].get("reverse_1", {})
        )
        
        if reverse_bet and reverse_level > 0:
            final_bet_type = reverse_bet
            base_level = reverse_level
            is_reverse = True
        else:
            # åŸæœ‰é–¾é–¾å€¼åˆ¤æ–·é‚è¼¯
            for level in ['7', '6', '5', '4', '3', '2', '1', '0']:  # æ–°å¢'0'ç´šåˆ¥
                if level in thresholds_dict[bet_type]:
                    threshold = thresholds_dict[bet_type][level]
                    
                    if current_prob < threshold.get("min_prob", 0):
                        continue
                    
                    if (threshold["min_change"] <= abs(percentage_change) < threshold["max_change"] and 
                        acceleration >= threshold["min_accel"]):
                        
                        base_level = threshold["level"]
                        
                        if threshold.get("reverse", False) or threshold.get("win_rate", 50) < 49:
                            final_bet_type = 'player' if bet_type == 'banker' else 'banker'
                            base_level = 1
                            is_reverse = True
                        
                        if not threshold.get("reverse", False) and threshold.get("win_rate", 50) >= 49:
                            final_level = min(20, base_level + cumulative_bonus)
                        else:
                            final_level = base_level
                        
                        return final_level, final_bet_type, is_reverse
        
        # åå‘é‚è¼¯çš„ç­‰ç´šè¨ˆç®—
        if is_reverse:
            trend_state = {
                'trend_strength': self.trend_strength,
                'cumulative_changes': self.cumulative_changes
            }
            reverse_level_adjusted = get_reverse_bet_level(
                bet_type, current_prob, percentage_change, acceleration, trend_state
            )
            final_level = max(1, min(5, base_level + reverse_level_adjusted))
            
            return final_level, final_bet_type, is_reverse
        
        return 0, bet_type, False

    def initialize_deck(self, num_decks=10):
        deck = []
        for _ in range(num_decks):
            for card in card_names:
                deck.extend([card] * 4)
        random.shuffle(deck)
        return deck

    def calculate_baccarat_score(self, hand):
        return sum(card_values[card] for card in hand) % 10

    def should_player_draw(self, player_score, banker_score):
        if player_score >= 8 or banker_score >= 8:
            return False
        return player_score < 6

    def should_banker_draw(self, banker_score, player_score, player_drew, player_third_card_value=None):
        if player_score >= 8 or banker_score >= 8:
            return False
            
        if not player_drew:
            return banker_score < 6
        else:
            if banker_score <= 2:
                return True
            elif banker_score == 3:
                return player_third_card_value != 8
            elif banker_score == 4:
                return player_third_card_value in [2, 3, 4, 5, 6, 7]
            elif banker_score == 5:
                return player_third_card_value in [4, 5, 6, 7]
            elif banker_score == 6:
                return player_third_card_value in [6, 7]
            else:
                return False

    def simulate_baccarat_round(self, input_cards=None):
        if len(self.remaining_deck) < 6:
            self.remaining_deck = self.initialize_deck(self.decks)
            print("ç‰Œå †ä¸è¶³ï¼Œé‡æ–°æ´—ç‰Œ")
        
        if input_cards and len(input_cards) >= 4:
            player_hand = [input_cards[0], input_cards[1]]
            banker_hand = [input_cards[2], input_cards[3]]
            
            for card in input_cards[:4]:
                if card in self.remaining_deck:
                    self.remaining_deck.remove(card)
        else:
            player_hand = [self.remaining_deck.pop(0), self.remaining_deck.pop(0)]
            banker_hand = [self.remaining_deck.pop(0), self.remaining_deck.pop(0)]
        
        player_score = self.calculate_baccarat_score(player_hand)
        banker_score = self.calculate_baccarat_score(banker_hand)
        
        player_drew = False
        player_third_card_value = None
        
        if self.should_player_draw(player_score, banker_score):
            if input_cards and len(input_cards) >= 5:
                player_third_card = input_cards[4]
                if player_third_card in self.remaining_deck:
                    self.remaining_deck.remove(player_third_card)
            else:
                player_third_card = self.remaining_deck.pop(0)
                
            player_hand.append(player_third_card)
            player_score = self.calculate_baccarat_score(player_hand)
            player_drew = True
            player_third_card_value = card_values[player_third_card]
        
        if self.should_banker_draw(banker_score, player_score, player_drew, player_third_card_value):
            if input_cards and len(input_cards) >= 6:
                banker_third_card = input_cards[5]
                if banker_third_card in self.remaining_deck:
                    self.remaining_deck.remove(banker_third_card)
            else:
                banker_third_card = self.remaining_deck.pop(0)
                
            banker_hand.append(banker_third_card)
            banker_score = self.calculate_baccarat_score(banker_hand)
        
        return banker_hand, player_hand, banker_score, player_score

    def calculate_remaining_probabilities(self):
        total_cards = len(self.remaining_deck)
        total_initial_cards = self.decks * 52
        
        if total_cards < 20:
            self.remaining_deck = self.initialize_deck(self.decks)
            self.current_probs = self.base_probabilities.copy()
            return
        
        card_counts = {}
        for card in card_names:
            count = self.remaining_deck.count(card)
            card_counts[card] = count
        
        point_ratios = {}
        for point in range(0, 10):
            if point == 0:
                cards_for_point = ['10', 'J', 'Q', 'K']
            else:
                cards_for_point = [card for card in card_names if card_values[card] == point]
            
            total_count = sum(card_counts[card] for card in cards_for_point)
            point_ratios[point] = total_count / total_cards
        
        high_card_ratio = point_ratios[0]
        low_card_ratio = sum(point_ratios[i] for i in [1, 2, 3, 4, 5])
        medium_card_ratio = sum(point_ratios[i] for i in [6, 7])
        eight_nine_ratio = sum(point_ratios[i] for i in [8, 9])
        
        banker_adjust = (eight_nine_ratio - 0.158) * 8 - (low_card_ratio - 0.385) * 4
        player_adjust = (low_card_ratio - 0.385) * 8 - (eight_nine_ratio - 0.158) * 4
        tie_adjust = (medium_card_ratio - 0.308) * 6
        
        consumption_ratio = (total_initial_cards - total_cards) / total_initial_cards
        consumption_effect = consumption_ratio * 2
        
        self.current_probs['banker'] = self.base_probabilities['banker'] + banker_adjust + consumption_effect
        self.current_probs['player'] = self.base_probabilities['player'] + player_adjust - consumption_effect
        self.current_probs['tie'] = self.base_probabilities['tie'] + tie_adjust
        
        self.current_probs['banker'] = max(40.0, min(52.0, self.current_probs['banker']))
        self.current_probs['player'] = max(40.0, min(52.0, self.current_probs['player']))
        self.current_probs['tie'] = max(5.0, min(15.0, self.current_probs['tie']))
        
        self.normalize_probabilities()

    def normalize_probabilities(self):
        total = sum(self.current_probs[bet] for bet in ['banker', 'player', 'tie'])
        if total > 0:
            scale = 100.0 / total
            for bet in ['banker', 'player', 'tie']:
                self.current_probs[bet] *= scale
                self.current_probs[bet] = round(self.current_probs[bet], 3)

    def calculate_ev(self, probability, payout):
        win_prob = probability / 100
        return (win_prob * payout) - ((1 - win_prob) * 1)

    def calculate_percentage_change(self, current_prob, base_prob):
        if base_prob == 0:
            return 0
        return ((current_prob - base_prob) / base_prob) * 100

    def get_recommendation_text(self, bet_type):
        if bet_type not in self.current_probs:
            return None
            
        current_prob = self.current_probs[bet_type]
        base_prob = self.base_probabilities[bet_type]
        payout = self.payouts[bet_type]
        ev = self.calculate_ev(current_prob, payout)
        
        percentage_change = self.calculate_percentage_change(current_prob, base_prob)
        
        acceleration = self.calculate_acceleration(percentage_change, self.previous_changes[bet_type])
        
        self.update_trend_strength(bet_type, acceleration, percentage_change)
        
        bet_level, final_bet_type, is_reverse = self.get_bet_recommendation(bet_type, percentage_change, acceleration)
        
        if bet_type == 'tie' and not self.observe_tie:
            return None
        
        chinese_names = {'banker': 'èŠ', 'player': 'é–’', 'tie': 'å’Œ'}
        
        # ç­‰ç´šåœ–æ¨™ï¼ˆåŒ…å«åå‘æ¨™è¨˜ï¼‰
        level_icons = {
            20: 'ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ ä¸‹20æ³¨',
            19: 'ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ ä¸‹19æ³¨',
            18: 'ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ ä¸‹18æ³¨',
            17: 'ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ ä¸‹17æ³¨',
            16: 'ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ ä¸‹16æ³¨',
            15: 'ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ ä¸‹15æ³¨',
            14: 'ğŸ”¥ğŸ”¥ğŸ”¥ ä¸‹14æ³¨',
            13: 'ğŸ”¥ğŸ”¥ğŸ”¥ ä¸‹13æ³¨',
            12: 'ğŸ”¥ğŸ”¥ğŸ”¥ ä¸‹12æ³¨',
            11: 'ğŸ”¥ğŸ”¥ ä¸‹11æ³¨',
            10: 'ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ ä¸‹10æ³¨',
            9: 'ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ ä¸‹9æ³¨',
            8: 'ğŸ”¥ğŸ”¥ğŸ”¥ ä¸‹8æ³¨',
            7: 'ğŸ”¥ğŸ”¥ ä¸‹7æ³¨',
            6: 'ğŸ”¥ ä¸‹6æ³¨',
            5: 'ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ ä¸‹5æ³¨',
            4: 'ğŸ”¥ğŸ”¥ğŸ”¥ ä¸‹4æ³¨', 
            3: 'ğŸ”¥ğŸ”¥ ä¸‹3æ³¨',
            2: 'ğŸ”¥ ä¸‹2æ³¨',
            1: 'âš¡âš¡ ä¸‹1æ³¨',
            0: 'âšªâšª ä¸ä¸‹æ³¨'
        }
        
        # ç¢ºä¿ bet_level åœ¨ level_icons ä¸­æœ‰å°æ‡‰çš„éµ
        if bet_level not in level_icons:
            available_levels = sorted(level_icons.keys(), reverse=True)
            for level in available_levels:
                if bet_level >= level:
                    bet_level = level
                    break
            else:
                bet_level = 0
        
        trend_icon = "â†‘" if acceleration > 0 else "â†“" if acceleration < 0 else "â†’"
        trend_strength = f"{abs(self.trend_strength[bet_type]):.1f}"
        cumulative_change = f"{self.cumulative_changes[bet_type]:.2f}"
        decay_counter = self.trend_decay_counter[bet_type]
        
        win_rate_info = ""
        for level in ['7', '6', '5', '4', '3', '2', '1', '0']:
            if level in thresholds_dict[bet_type]:
                threshold = thresholds_dict[bet_type][level]
                if (threshold["min_change"] <= abs(percentage_change) < threshold["max_change"] and 
                    acceleration >= threshold["min_accel"] and
                    current_prob >= threshold.get("min_prob", 0)):
                    win_rate_info = f" | å‹ç‡: {threshold.get('win_rate', 50):.1f}%"
                    break
        
        reverse_indicator = "ğŸ”„ğŸ”„ " if is_reverse else ""
        
        recommendation_text = (
            f"{reverse_indicator}{chinese_names[final_bet_type]}:\n"
            f"  æ¦‚ç‡: {current_prob:.3f} (åŸº{base_prob:.3f})\n"
            f"  è®ŠåŒ–: {percentage_change:+.2f}% | åŠ é€Ÿ: {acceleration:+.2f}% {trend_icon}{win_rate_info}\n"
            f"  è¶¨å‹¢å¼·åº¦: {trend_strength} | ç´¯ç©: {cumulative_change}% | è¡°æ¸›è¨ˆæ•¸: {decay_counter}\n"
            f"  EV: {ev:+.3f} | æ¨è–¦: {level_icons[bet_level]}\n"
            f"{'='*30}\n"
        )
        
        return {
            'text': recommendation_text,
            'level': bet_level,
            'ev': ev,
            'change': percentage_change,
            'acceleration': acceleration,
            'bet_type': final_bet_type,
            'current_prob': current_prob,
            'base_prob': base_prob,
            'trend_strength': self.trend_strength[bet_type],
            'cumulative_change': self.cumulative_changes[bet_type],
            'decay_counter': decay_counter,
            'is_reverse': is_reverse
        }

    def get_top_recommendation(self):
        recommendations = []
        
        for bet_type in ['banker', 'player']:
            recommendation = self.get_recommendation_text(bet_type)
            if recommendation and recommendation['level'] > 0:
                recommendations.append(recommendation)
        
        if recommendations:
            recommendations.sort(key=lambda x: (x['level'], abs(x['trend_strength'])), reverse=True)
            return recommendations[0]['bet_type'], recommendations[0]['level'], recommendations
        else:
            self.consecutive_no_recommendation += 1
            
            all_recommendations = []
            for bet_type in ['banker', 'player']:
                rec = self.get_recommendation_text(bet_type)
                if rec:
                    all_recommendations.append(rec)
            return None, 0, all_recommendations

    def take_recommendation_snapshot(self):
        snapshot = {
            'banker': self.get_recommendation_text('banker'),
            'player': self.get_recommendation_text('player'),
            'timestamp': self.game_count
        }
        return snapshot

    def update_probabilities_display_only(self):
        if len(self.current_cards) > 0:
            self.calculate_remaining_probabilities()
        
        for key, label in self.prob_labels.items():
            label.config(text=f"{self.current_probs[key]:.3f}")
        
        gpu_status = " | GPUåŠ é€Ÿ: å¯ç”¨" if self.gpu_enabled else " | GPUåŠ é€Ÿ: ä¸å¯ç”¨"
        self.status_label.config(text=f"å±€æ•¸ï¼š#{self.game_count} | Aç‰Œï¼š{self.a_count} | å‰©é¤˜ç‰Œï¼š{len(self.remaining_deck)} | æ¨è–¦ç¯„åœï¼š{self.THRESHOLD_min_games}-{self.THRESHOLD_max_games}å±€{gpu_status}")
        
        if self.game_count < self.THRESHOLD_min_games:
            status_text = f"ç­‰å¾…æ¨è–¦ç¯„åœï¼ˆ{self.THRESHOLD_min_games}å±€é–‹å§‹ï¼‰"
            color = '#ff6666'
        elif self.game_count <= self.THRESHOLD_max_games:
            status_text = "æ¨è–¦ç¯„åœå…§ï¼Œåˆ†æä¸­..."
            color = '#ffcc00'
        else:
            status_text = "å·²è¶…å‡ºæ¨è–¦ç¯„åœ"
            color = '#00cc66'
            
        if self.trend_filter_enabled:
            status_text += f" | è¶¨å‹¢éæ¿¾(å¼·åº¦â‰¥{self.min_trend_strength})"
            color = '#00ff00'
            
        self.data_status_label.config(text=status_text, fg=color)
        
        self.update_recommendation_display()

   # UIè¨­ç½® - å®Œå…¨æ¢å¾©v3.8.4ä½ˆå±€ + V2.1.1é«˜æ¨è–¦ç‡å„ªåŒ–
def setup_ui(self):
    title_frame = tk.Frame(self.root, bg='#2d2d2d', height=50)
    title_frame.pack(fill=tk.X, padx=10, pady=3)
    title_frame.pack_propagate(False)
    
    title_text = "ç™¾å®¶æ¨‚ AI ç®—ç‰Œé æ¸¬ v3.8.4 - GPU-DP-V2.1.1ï¼ˆé«˜æ¨è–¦ç‡å„ªåŒ–ç‰ˆï¼‰"
    if self.gpu_enabled:
        title_text += " - GPUåŠ é€Ÿå·²å•Ÿç”¨"
    else:
        title_text += " - GPUåŠ é€Ÿä¸å¯ç”¨"
        
    tk.Label(title_frame, text=title_text, 
            font=('Microsoft YaHei', 14, 'bold'), fg='white', bg='#2d2d2d').pack(expand=True)
    
    status_frame = tk.Frame(self.root, bg='#333333', height=35)
    status_frame.pack(fill=tk.X, padx=10, pady=2)
    status_frame.pack_propagate(False)
    
    gpu_status = " | GPUåŠ é€Ÿ: å¯ç”¨" if self.gpu_enabled else " | GPUåŠ é€Ÿ: ä¸å¯ç”¨"
    self.status_label = tk.Label(status_frame, 
                                text=f"å±€æ•¸ï¼š#{self.game_count} | Aç‰Œï¼š{self.a_count} | å‰©é¤˜ç‰Œï¼š{len(self.remaining_deck)} | æ¨è–¦ç¯„åœï¼š{self.THRESHOLD_min_games}-{self.THRESHOLD_max_games}å±€{gpu_status}",
                                font=('Microsoft YaHei', 10), fg='#ffcc00', bg='#333333')
    self.status_label.pack(side=tk.LEFT, padx=10)
    
    self.data_status_label = tk.Label(status_frame, text=f"v3.8.4é«˜æ¨è–¦ç‡ç³»çµ± - æœ€å°å¼·åº¦:{self.min_trend_strength}",
                                     font=('Microsoft YaHei', 10), fg='#00ff00', bg='#333333')
    self.data_status_label.pack(side=tk.RIGHT, padx=10)
    
    main_frame = tk.Frame(self.root, bg='#1a1a1a')
    main_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=3)
    
    left_frame = tk.Frame(main_frame, bg='#2d2d2d', width=400)
    left_frame.pack(side=tk.LEFT, fill=tk.Y, padx=(0, 5))
    left_frame.pack_propagate(False)
    
    right_frame = tk.Frame(main_frame, bg='#1a1a1a')
    right_frame.pack(side=tk.RIGHT, fill=tk.BOTH, expand=True, padx=(5, 0))
    
    self.setup_recommendation_panel(left_frame)
    self.setup_table_panel(right_frame)
    
def setup_recommendation_panel(self, parent):
    param_frame = tk.LabelFrame(parent, text="åƒæ•¸è¨­å®š v3.8.4-HR", font=('Microsoft YaHei', 10, 'bold'),
                              fg='white', bg='#2d2d2d', bd=1, height=180)
    param_frame.pack(fill=tk.X, padx=5, pady=3)
    param_frame.pack_propagate(False)
    
    # GPUæ§åˆ¶
    gpu_frame = tk.Frame(param_frame, bg='#2d2d2d')
    gpu_frame.pack(fill=tk.X, padx=5, pady=2)
    
    if self.gpu_enabled:
        gpu_color = '#00ff00'
        gpu_text = "GPUåŠ é€Ÿ: å¯ç”¨ (v3.8.4é«˜æ¨è–¦ç‡ç³»çµ±)"
    else:
        gpu_color = '#ff6666'
        gpu_text = "GPUåŠ é€Ÿ: ä¸å¯ç”¨"
        
    tk.Label(gpu_frame, text=gpu_text, font=('Microsoft YaHei', 9, 'bold'),
            fg=gpu_color, bg='#2d2d2d').pack(side=tk.LEFT)
    
    # é«˜æ¨è–¦ç‡æ¨¡å¼æŒ‰éˆ•
    hr_btn_frame = tk.Frame(gpu_frame, bg='#2d2d2d')
    hr_btn_frame.pack(side=tk.RIGHT, padx=5)
    
    tk.Button(hr_btn_frame, text="å•Ÿç”¨é«˜æ¨è–¦ç‡", font=('Microsoft YaHei', 8),
             command=self.enable_high_recommendation_mode, bg='#9b59b6', fg='white', width=10).pack(side=tk.LEFT, padx=2)
    
    # è¶¨å‹¢éæ¿¾æ§åˆ¶
    trend_frame = tk.Frame(param_frame, bg='#2d2d2d')
    trend_frame.pack(fill=tk.X, padx=5, pady=2)
    
    self.trend_filter_var = tk.BooleanVar(value=self.trend_filter_enabled)
    trend_check = tk.Checkbutton(trend_frame, text="è¶¨å‹¢éæ¿¾", variable=self.trend_filter_var,
                               command=self.toggle_trend_filter, font=('Microsoft YaHei', 9),
                               fg='white', bg='#2d2d2d', selectcolor='#1a1a1a')
    trend_check.pack(side=tk.LEFT)
    
    tk.Label(trend_frame, text="æœ€å°è¶¨å‹¢å¼·åº¦:", font=('Microsoft YaHei', 8), 
            fg='white', bg='#2d2d2d').pack(side=tk.LEFT, padx=(10,2))
    
    self.min_trend_var = tk.StringVar(value="0.0001")  # è¨­ç½®ç‚ºé«˜æ¨è–¦ç‡åƒæ•¸
    trend_spinbox = tk.Spinbox(trend_frame, from_=0.0001, to=0.5, increment=0.0001, width=8,
                             textvariable=self.min_trend_var, command=self.update_trend_settings,
                             font=('Microsoft YaHei', 8))
    trend_spinbox.pack(side=tk.LEFT, padx=2)
    
    range_frame = tk.Frame(param_frame, bg='#2d2d2d')
    range_frame.pack(fill=tk.X, padx=5, pady=2)
    
    tk.Label(range_frame, text="æ¨è–¦ç¯„åœ:", font=('Microsoft YaHei', 9), 
            fg='white', bg='#2d2d2d').pack(side=tk.LEFT)
    
    self.min_games_var = tk.StringVar(value=str(self.THRESHOLD_min_games))
    min_spinbox = tk.Spinbox(range_frame, from_=1, to=100, width=4,
                           textvariable=self.min_games_var, command=self.update_thresholds,
                           font=('Microsoft YaHei', 8))
    min_spinbox.pack(side=tk.LEFT, padx=2)
    
    tk.Label(range_frame, text="å±€~", font=('Microsoft YaHei', 8), 
            fg='white', bg='#2d2d2d').pack(side=tk.LEFT)
    
    self.max_games_var = tk.StringVar(value=str(self.THRESHOLD_max_games))
    max_spinbox = tk.Spinbox(range_frame, from_=10, to=200, width=4,
                           textvariable=self.max_games_var, command=self.update_thresholds,
                           font=('Microsoft YaHei', 8))
    max_spinbox.pack(side=tk.LEFT, padx=2)
    
    tk.Label(range_frame, text="å±€", font=('Microsoft YaHei', 8), 
            fg='white', bg='#2d2d2d').pack(side=tk.LEFT)
    
    auto_frame = tk.Frame(param_frame, bg='#2d2d2d')
    auto_frame.pack(fill=tk.X, padx=5, pady=2)
    
    tk.Label(auto_frame, text="è‡ªå‹•æ¨¡æ“¬:", font=('Microsoft YaHei', 9), 
            fg='white', bg='#2d2d2d').pack(side=tk.LEFT)
    
    self.auto_games_var = tk.StringVar(value="10000")
    auto_spinbox = tk.Spinbox(auto_frame, from_=1, to=100000, width=8,
                            textvariable=self.auto_games_var,
                            font=('Microsoft YaHei', 8))
    auto_spinbox.pack(side=tk.LEFT, padx=2)
    
    tk.Label(auto_frame, text="å±€", font=('Microsoft YaHei', 8), 
            fg='white', bg='#2d2d2d').pack(side=tk.LEFT)
    
    sim_btn_frame = tk.Frame(auto_frame, bg='#2d2d2d')
    sim_btn_frame.pack(side=tk.RIGHT, padx=5)
    
    tk.Button(sim_btn_frame, text="GPUæ¨¡æ“¬", font=('Microsoft YaHei', 8),
             command=lambda: self.start_gpu_simulation(int(self.auto_games_var.get())), 
             bg='#9b59b6', fg='white', width=8).pack(side=tk.LEFT, padx=2)
    
    tk.Button(sim_btn_frame, text="CPUæ¨¡æ“¬", font=('Microsoft YaHei', 8),
             command=self.start_auto_simulate, bg='#e74c3c', width=8).pack(side=tk.LEFT, padx=2)
    
    tk.Button(sim_btn_frame, text="åœæ­¢", font=('Microsoft YaHei', 8),
             command=self.stop_auto_simulate, bg='#95a5a6', width=6).pack(side=tk.LEFT, padx=2)
    
    strategy_frame = tk.LabelFrame(parent, text="ç­–ç•¥è¨­å®š", font=('Microsoft YaHei', 10, 'bold'),
                                  fg='white', bg='#2d2d2d', bd=1, height=60)
    strategy_frame.pack(fill=tk.X, padx=5, pady=3)
    strategy_frame.pack_propagate(False)
    
    btn_frame = tk.Frame(strategy_frame, bg='#2d2d2d')
    btn_frame.pack(fill=tk.X, padx=3, pady=2)
    
    tk.Button(btn_frame, text="èŠé–’å°ˆç”¨", font=('Microsoft YaHei', 8),
             command=lambda: self.set_strategy('bp'), bg='#3498db', width=8).pack(side=tk.LEFT, padx=1)
    
    strategy_text = f"ç•¶å‰: èŠé–’å°ˆç”¨ç­–ç•¥ | v3.8.4é«˜æ¨è–¦ç‡ç³»çµ±"
    if self.gpu_enabled:
        strategy_text += " | GPUåŠ é€Ÿ"
        
    self.strategy_label = tk.Label(strategy_frame, text=strategy_text, 
                                  font=('Microsoft YaHei', 9), fg='#ffcc00', bg='#2d2d2d')
    self.strategy_label.pack(pady=1)
    
    ai_frame = tk.LabelFrame(parent, text="AIæ¨è–¦ä¸‹æ³¨", font=('Microsoft YaHei', 12, 'bold'),
                            fg='white', bg='#2d2d2d', bd=2)
    ai_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=3)
    
    self.recommendation_text = tk.Text(ai_frame, height=12, font=('Microsoft YaHei', 9),
                                      fg='white', bg='#1a1a1a', wrap=tk.WORD)
    scrollbar = tk.Scrollbar(ai_frame, command=self.recommendation_text.yview)
    self.recommendation_text.config(yscrollcommand=scrollbar.set)
    self.recommendation_text.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
    scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
    
    self.result_label = tk.Label(ai_frame, text="", font=('Microsoft YaHei', 14, 'bold'),
                                fg='#ffcc00', bg='#2d2d2d')
    self.result_label.pack(fill=tk.X, side=tk.BOTTOM, pady=5)
    
    self.update_recommendation_display()
    
def setup_table_panel(self, parent):
    prob_frame = tk.Frame(parent, bg='#2d2d2d', height=150)
    prob_frame.pack(fill=tk.X, pady=3)
    prob_frame.pack_propagate(False)
    
    self.setup_probability_display(prob_frame)
    
    card_frame = tk.Frame(parent, bg='#1a1a1a')
    card_frame.pack(fill=tk.BOTH, expand=True)
    
    self.setup_card_buttons(card_frame)
    
    bottom_frame = tk.Frame(parent, bg='#2d2d2d', height=60)
    bottom_frame.pack(fill=tk.X, pady=3)
    bottom_frame.pack_propagate(False)
    
    self.setup_bottom_controls(bottom_frame)
    
def setup_probability_display(self, parent):
    prob_grid = tk.Frame(parent, bg='#2d2d2d')
    prob_grid.pack(expand=True, fill=tk.BOTH, padx=5, pady=5)
    
    prob_items = [
        ('é–’', 'player', '#ff6b6b'),
        ('èŠ', 'banker', '#4ecdc4'), 
        ('å’Œ', 'tie', '#45b7d1')
    ]
    
    self.prob_labels = {}
    
    for i, (name, key, color) in enumerate(prob_items):
        frame = tk.Frame(prob_grid, bg='#2d2d2d')
        frame.grid(row=0, column=i, sticky='ew', pady=1, padx=5)
        
        prob_frame = tk.Frame(frame, bg='#3d3d3d', relief=tk.RAISED, bd=1, width=100, height=80)
        prob_frame.pack(side=tk.LEFT, expand=True, fill=tk.BOTH, padx=1)
        prob_frame.pack_propagate(False)
        
        title_label = tk.Label(prob_frame, text=name, font=('Microsoft YaHei', 9, 'bold'),
                              fg='white', bg=color, height=1)
        title_label.pack(fill=tk.X)
        
        prob_label = tk.Label(prob_frame, text=f"{self.current_probs[key]:.3f}", 
                             font=('Microsoft YaHei', 10, 'bold'), fg='white', bg='#3d3d3d')
        prob_label.pack(expand=True)
        
        self.prob_labels[key] = prob_label
        
def setup_card_buttons(self, parent):
    self.current_cards_label = tk.Label(parent, text="ç•¶å‰ç‰Œå±€ï¼šç­‰å¾…è¼¸å…¥...", 
                                       font=('Microsoft YaHei', 12), fg='white', bg='#1a1a1a')
    self.current_cards_label.pack(pady=5)
    
    row1_frame = tk.Frame(parent, bg='#1a1a1a')
    row1_frame.pack(fill=tk.X, pady=2)
    
    cards_row1 = ['A', '2', '3', '4', '5']
    for card in cards_row1:
        btn = tk.Button(row1_frame, text=card, font=('Arial', 20, 'bold'),
                       width=6, height=2, bg='#e74c3c', fg='white',
                       command=lambda c=card: self.card_clicked(c))
        btn.pack(side=tk.LEFT, padx=2)
    
    row2_frame = tk.Frame(parent, bg='#1a1a1a')
    row2_frame.pack(fill=tk.X, pady=2)
    
    cards_row2 = ['6', '7', '8', '9', '10']
    for card in cards_row2:
        btn = tk.Button(row2_frame, text=card, font=('Arial', 20, 'bold'),
                       width=6, height=2, bg='#3498db', fg='white',
                       command=lambda c=card: self.card_clicked(c))
        btn.pack(side=tk.LEFT, padx=2)
    
    row3_frame = tk.Frame(parent, bg='#1a1a1a')
    row3_frame.pack(fill=tk.X, pady=2)
    
    cards_row3 = ['J', 'Q', 'K']
    for card in cards_row3:
        btn = tk.Button(row3_frame, text=card, font=('Arial', 20, 'bold'),
                       width=6, height=2, bg='#9b59b6', fg='white',
                       command=lambda c=card: self.card_clicked(c))
        btn.pack(side=tk.LEFT, padx=2)
        
def setup_bottom_controls(self, parent):
    control_frame = tk.Frame(parent, bg='#2d2d2d')
    control_frame.pack(expand=True)
    
    tk.Button(control_frame, text="å®Œæˆæœ¬å±€", font=('Microsoft YaHei', 10),
             bg='#27ae60', fg='white', width=10, height=1,
             command=self.complete_round).pack(side=tk.LEFT, padx=5)
    
    tk.Button(control_frame, text="é‡æ–°è¼¸å…¥", font=('Microsoft YaHei', 10),
             bg='#e67e22', fg='white', width=10, height=1,
             command=self.reset_input).pack(side=tk.LEFT, padx=5)
    
    tk.Button(control_frame, text="æ­·å²åˆ†æ", font=('Microsoft YaHei', 10),
             bg='#3498db', fg='white', width=10, height=1,
             command=self.show_history).pack(side=tk.LEFT, padx=5)
    
    tk.Button(control_frame, text="å–®å±€æ¨¡æ“¬", font=('Microsoft YaHei', 10),
             bg='#9b59b6', fg='white', width=10, height=1,
             command=self.auto_simulate).pack(side=tk.LEFT, padx=5)
    
    tk.Button(control_frame, text="é‡ç½®ç³»çµ±", font=('Microsoft YaHei', 10),
             bg='#e74c3c', fg='white', width=10, height=1,
             command=self.reset_system).pack(side=tk.LEFT, padx=5)
    
    tk.Button(control_frame, text="å°å‡ºCSV", font=('Microsoft YaHei', 10),
             bg='#f39c12', fg='white', width=10, height=1,
             command=self.export_to_csv).pack(side=tk.LEFT, padx=5)
    
    path_frame = tk.Frame(parent, bg='#2d2d2d', height=25)
    path_frame.pack(fill=tk.X, pady=2)
    path_frame.pack_propagate(False)
    
    self.path_label = tk.Label(path_frame, text=f"å°å‡ºè·¯å¾‘: {self.export_path}", 
                              font=('Microsoft YaHei', 8), fg='#cccccc', bg='#2d2d2d')
    self.path_label.pack(side=tk.LEFT, padx=10)
    
    tk.Button(path_frame, text="æ›´æ”¹è·¯å¾‘", font=('Microsoft YaHei', 8),
             command=self.change_export_path, bg='#34495e', fg='white', width=8).pack(side=tk.RIGHT, padx=10)
    
def change_export_path(self):
    new_path = filedialog.askdirectory(title="é¸æ“‡CSVå°å‡ºç›®éŒ„")
    if new_path:
        self.export_path = new_path
        self.path_label.config(text=f"å°å‡ºè·¯å¾‘: {self.export_path}")
        messagebox.showinfo("æˆåŠŸ", f"å°å‡ºè·¯å¾‘å·²æ›´æ”¹ç‚º: {self.export_path}")
        
def card_clicked(self, card):
    if len(self.current_cards) >= 6:
        messagebox.showwarning("è­¦å‘Š", "ä¸€å±€æœ€å¤š6å¼µç‰Œï¼")
        return
        
    self.current_cards.append(card)
    
    if card in self.remaining_deck:
        self.remaining_deck.remove(card)
    
    if card == 'A':
        self.a_count += 1
        
    cards_text = f"ç•¶å‰ç‰Œå±€ï¼š{' '.join(self.current_cards)}"
    self.current_cards_label.config(text=cards_text)
    
    self.update_probabilities_display_only()
    
def toggle_trend_filter(self):
    self.trend_filter_enabled = self.trend_filter_var.get()
    status = "å•Ÿç”¨" if self.trend_filter_enabled else "ç¦ç”¨"
    self.data_status_label.config(text=f"v3.8.4é«˜æ¨è–¦ç‡ç³»çµ±{status} - æœ€å°å¼·åº¦:{self.min_trend_strength}", fg='#00ff00')

# ç²¾æº–åå‘é‚è¼¯ç³»çµ± - å¤šç¶­åº¦åå‘ä¿¡è™Ÿæª¢æ¸¬
def improved_reverse_evaluation(self, bet_type, current_prob, percentage_change, acceleration, trend_state, other_param, threshold=0.6):
    """å¤šç¶­åº¦åˆ¤æ–·æ˜¯å¦æ‡‰è©²åå‘ä¸‹æ³¨ - v3.8.4é«˜æ¨è–¦ç‡å„ªåŒ–ç‰ˆæœ¬"""
    
    # ä¿¡è™Ÿ1: æ¦‚ç‡éé«˜ä½†è¶¨å‹¢è¡°æ¸›ï¼ˆå¤§å¹…æ”¾å¯¬æ¢ä»¶ï¼‰
    if current_prob > 47.5 and acceleration < -0.08:  # å¾48.0é™ä½åˆ°47.5ï¼Œå¾-0.1æ”¾å¯¬åˆ°-0.08
        return True, 2
    
    # ä¿¡è™Ÿ2: è®ŠåŒ–ç‡èˆ‡è¶¨å‹¢å¼·åº¦èƒŒé›¢ï¼ˆæ”¾å¯¬æ¢ä»¶ï¼‰
    if (percentage_change > 0.8 and trend_state['trend_strength'][bet_type] < -0.8) or \
       (percentage_change < -0.8 and trend_state['trend_strength'][bet_type] > 0.8):
        return True, 2
    
    # ä¿¡è™Ÿ3: é€£çºŒåŒå‘è®ŠåŒ–å¾Œçš„è½‰æŠ˜é»ï¼ˆæ¸›å°‘é€£çºŒæ¬¡æ•¸è¦æ±‚ï¼‰
    change_history = trend_state['change_history'][bet_type]
    if len(change_history) >= 2:  # å¾3æ¬¡é™ä½åˆ°2æ¬¡
        # å¦‚æœé€£çºŒ2æ¬¡åŒå‘è®ŠåŒ–ï¼Œå¯èƒ½å‡ºç¾åè½‰
        if all(c > 0 for c in change_history[-2:]) and acceleration < -0.15:
            return True, 2
        if all(c < 0 for c in change_history[-2:]) and acceleration > 0.15:
            return True, 2
    
    # ä¿¡è™Ÿ4: æ¥µç«¯æ¦‚ç‡å€¼çš„å‡å€¼å›æ­¸ï¼ˆæ”¾å¯¬æ¥µå€¼ç¯„åœï¼‰
    if current_prob > 49.0 or current_prob < 43.0:  # å¾49.5/42.0æ”¾å¯¬åˆ°49.0/43.0
        return True, 1
    
    # ä¿¡è™Ÿ5: ç´¯ç©è®ŠåŒ–éåº¦å¾Œçš„ä¿®æ­£ï¼ˆé™ä½é–€æª»ï¼‰
    if abs(trend_state['cumulative_changes'][bet_type]) > 2.5:  # å¾3.0é™ä½åˆ°2.5
        return True, 1
    
    # ä¿¡è™Ÿ6: æ™‚é–“åºåˆ—åè½‰æ¨¡å¼æª¢æ¸¬ï¼ˆæ–°å¢ï¼‰
    if self.detect_reversal_pattern(change_history, percentage_change, acceleration):
        return True, 3  # æ›´å¼·çš„ä¿¡è™Ÿ
    
    return False, 0

# åå‘é‚è¼¯åˆ†ç´šç³»çµ±
def get_reverse_bet_level(self, bet_type, current_prob, percentage_change, acceleration, trend_state):
    """æ ¹æ“šåå‘ä¿¡è™Ÿå¼·åº¦ç¢ºå®šä¸‹æ³¨ç­‰ç´š - v3.8.4é«˜æ¨è–¦ç‡å„ªåŒ–ç‰ˆæœ¬"""
    
    reverse_signals = 0
    signal_strength = 0
    
    # ä¿¡è™Ÿå¼·åº¦è¨ˆç®—ï¼ˆå¤§å¹…æ”¾å¯¬æ¢ä»¶ï¼‰
    if current_prob > 48.0:  # å¾48.5é™ä½åˆ°48.0
        reverse_signals += 1
        signal_strength += (current_prob - 48.0) * 2
    
    if acceleration < -0.12:  # å¾-0.15æ”¾å¯¬åˆ°-0.12
        reverse_signals += 1
        signal_strength += abs(acceleration) * 12  # å¾10å¢åŠ åˆ°12
    
    if abs(trend_state['cumulative_changes'][bet_type]) > 2.0:  # å¾2.5é™ä½åˆ°2.0
        reverse_signals += 1
        signal_strength += abs(trend_state['cumulative_changes'][bet_type]) * 0.6  # å¾0.5å¢åŠ åˆ°0.6
    
    # è¶¨å‹¢èƒŒé›¢æª¢æ¸¬ï¼ˆæ”¾å¯¬æ¢ä»¶ï¼‰
    if (percentage_change > 0 and trend_state['trend_strength'][bet_type] < -0.8) or \
       (percentage_change < 0 and trend_state['trend_strength'][bet_type] > 0.8):
        reverse_signals += 2
        signal_strength += 2.0
    
    # æ™‚é–“åºåˆ—æ¨¡å¼æª¢æ¸¬ï¼ˆæ–°å¢ï¼‰
    change_history = trend_state['change_history'][bet_type]
    if len(change_history) >= 3:
        recent_changes = change_history[-3:] + [percentage_change]
        # æª¢æ¸¬é ­è‚©é ‚/åº•å½¢æ…‹
        if (recent_changes[0] > 1.0 and recent_changes[1] < 0.5 and recent_changes[2] > 0.8 and acceleration < -0.1) or \
           (recent_changes[0] < -1.0 and recent_changes[1] > -0.5 and recent_changes[2] < -0.8 and acceleration > 0.1):
            reverse_signals += 2
            signal_strength += 2.5
    
    # ç¢ºå®šåå‘ä¸‹æ³¨ç­‰ç´šï¼ˆå¤§å¹…æ”¾å¯¬ï¼‰
    if reverse_signals >= 2 and signal_strength > 2.0:  # å¾3ä¿¡è™Ÿ/3.0å¼·åº¦é™ä½åˆ°2/2.0
        return 3  # å¼·çƒˆåå‘ä¿¡è™Ÿ
    elif reverse_signals >= 1 and signal_strength > 1.0:  # å¾2/1.5é™ä½åˆ°1/1.0
        return 2  # ä¸­ç­‰åå‘ä¿¡è™Ÿ
    elif reverse_signals >= 1 and signal_strength > 0.3:  # æ–°å¢å¼±ä¿¡è™Ÿç´šåˆ¥
        return 1  # å¼±åå‘ä¿¡è™Ÿ
    else:
        return 0  # ç„¡åå‘ä¿¡è™Ÿ

# æ™‚é–“åºåˆ—æ¨¡å¼è­˜åˆ¥
def detect_reversal_pattern(change_history, current_change, acceleration):
    """æª¢æ¸¬åƒ¹æ ¼åè½‰æ¨¡å¼ - v3.8.4é«˜æ¨è–¦ç‡å„ªåŒ–ç‰ˆæœ¬"""
    if len(change_history) < 3:  # å¾4é™ä½åˆ°3
        return False
    
    recent_changes = change_history[-3:] + [current_change]
    
    # æ¨¡å¼1: é€£çºŒä¸Šæ¼²å¾Œçš„ä¸‹è·Œï¼ˆæ”¾å¯¬æ¢ä»¶ï¼‰
    if (all(c > 0 for c in recent_changes[:-2]) and 
        recent_changes[-2] < 0 and recent_changes[-1] < 0 and
        acceleration < -0.08):  # å¾-0.1æ”¾å¯¬åˆ°-0.08
        return True
    
    # æ¨¡å¼2: é€£çºŒä¸‹è·Œå¾Œçš„ä¸Šæ¼²ï¼ˆæ”¾å¯¬æ¢ä»¶ï¼‰
    if (all(c < 0 for c in recent_changes[:-2]) and 
        recent_changes[-2] > 0 and recent_changes[-1] > 0 and
        acceleration > 0.08):  # å¾0.1æ”¾å¯¬åˆ°0.08
        return True
    
    # æ¨¡å¼3: é«˜é»èƒŒé›¢ï¼ˆåƒ¹æ ¼æ–°é«˜ä½†å‹•èƒ½è¡°æ¸›ï¼Œæ”¾å¯¬æ¢ä»¶ï¼‰
    if (max(recent_changes[:-1]) > 0.8 and  # å¾1.0é™ä½åˆ°0.8
        current_change < max(recent_changes[:-1]) * 0.6 and  # å¾0.5å¢åŠ åˆ°0.6
        acceleration < -0.12):  # å¾-0.15æ”¾å¯¬åˆ°-0.12
        return True
    
    # æ¨¡å¼4: ä½é»èƒŒé›¢ï¼ˆåƒ¹æ ¼æ–°ä½ä½†å‹•èƒ½å¢å¼·ï¼Œæ–°å¢ï¼‰
    if (min(recent_changes[:-1]) < -0.8 and 
        current_change > min(recent_changes[:-1]) * 0.6 and
        acceleration > 0.12):
        return True
    
    # æ¨¡å¼5: é›™é ‚/é›™åº•å½¢æ…‹ï¼ˆæ–°å¢ï¼‰
    if len(recent_changes) >= 5:
        if (abs(recent_changes[-3] - recent_changes[-1]) < 0.3 and
            abs(recent_changes[-4] - recent_changes[-2]) < 0.3 and
            ((recent_changes[-3] > 0.8 and recent_changes[-1] > 0.8 and acceleration < -0.1) or
             (recent_changes[-3] < -0.8 and recent_changes[-1] < -0.8 and acceleration > 0.1))):
            return True
    
    return False

# å®Œæ•´çš„æ”¹é€²åå‘é‚è¼¯å¯¦ç¾
def improved_reverse_evaluation_full(bet_type, current_prob, percentage_change, acceleration, trend_state, threshold):
    """æ”¹é€²çš„åå‘ä¸‹æ³¨è©•ä¼° - v3.8.4é«˜æ¨è–¦ç‡å®Œæ•´ç‰ˆæœ¬"""
    
    # åŸºç¤æ¢ä»¶æª¢æŸ¥ï¼ˆå¤§å¹…æ”¾å¯¬ï¼‰
    if current_prob < threshold.get("min_prob", 42.0) or current_prob > threshold.get("max_prob", 52.0):
        return None, 0
    
    if not (threshold["min_change"] <= abs(percentage_change) < threshold["max_change"]):
        return None, 0
    
    if not (threshold["min_accel"] <= acceleration <= threshold.get("max_accel", 100)):
        return None, 0
    
    # å¤šç¶­åº¦åå‘ä¿¡è™Ÿæª¢æ¸¬
    reverse_signals = []
    signal_strengths = []
    
    # ä¿¡è™Ÿ1: è¶¨å‹¢å¼·åº¦èƒŒé›¢ï¼ˆæ”¾å¯¬æ¢ä»¶ï¼‰
    if trend_state['trend_strength'][bet_type] < threshold.get("min_trend_strength", -0.8):  # å¾-2.0æ”¾å¯¬åˆ°-0.8
        reverse_signals.append(1)
        signal_strengths.append(1.0)
    
    # ä¿¡è™Ÿ2: ç´¯ç©è®ŠåŒ–éåº¦ï¼ˆé™ä½é–€æª»ï¼‰
    if abs(trend_state['cumulative_changes'][bet_type]) > threshold.get("min_cumulative", 2.0):  # å¾3.0é™ä½åˆ°2.0
        reverse_signals.append(1)
        signal_strengths.append(min(2.0, abs(trend_state['cumulative_changes'][bet_type]) * 0.5))
    
    # ä¿¡è™Ÿ3: æ¦‚ç‡æ¥µå€¼ï¼ˆæ”¾å¯¬ç¯„åœï¼‰
    if current_prob > 48.5 or current_prob < 43.5:  # å¾49.5/42.0æ”¾å¯¬åˆ°48.5/43.5
        reverse_signals.append(1)
        signal_strengths.append(1.5 if current_prob > 49.0 or current_prob < 43.0 else 1.0)
    
    # ä¿¡è™Ÿ4: æ™‚é–“åºåˆ—åè½‰æ¨¡å¼ï¼ˆæ–°å¢ï¼‰
    if detect_reversal_pattern(trend_state['change_history'][bet_type], percentage_change, acceleration):
        reverse_signals.append(2)  # æ›´å¼·çš„ä¿¡è™Ÿ
        signal_strengths.append(2.0)
    
    # ä¿¡è™Ÿ5: åŠ é€Ÿè¡°æ¸›æª¢æ¸¬ï¼ˆæ–°å¢ï¼‰
    if acceleration < -0.15 and percentage_change > 0:  # å¼·çƒˆä¸Šæ¼²å¾Œå¿«é€Ÿè¡°æ¸›
        reverse_signals.append(2)
        signal_strengths.append(2.0)
    elif acceleration > 0.15 and percentage_change < 0:  # å¼·çƒˆä¸‹è·Œå¾Œå¿«é€Ÿåå½ˆ
        reverse_signals.append(2)
        signal_strengths.append(2.0)
    
    # ç¢ºå®šåå‘ä¸‹æ³¨
    if len(reverse_signals) >= 2 and sum(signal_strengths) >= 2.5:  # å¾3ä¿¡è™Ÿ/3.0å¼·åº¦é™ä½åˆ°2/2.5
        final_bet_type = 'player' if bet_type == 'banker' else 'banker'
        
        # æ ¹æ“šä¿¡è™Ÿå¼·åº¦ç¢ºå®šä¸‹æ³¨ç­‰ç´š
        total_strength = sum(signal_strengths)
        if total_strength >= 5.0:
            reverse_level = min(5, threshold["level"] + 3)  # å¼·åŠ›åå‘
        elif total_strength >= 3.5:
            reverse_level = min(4, threshold["level"] + 2)  # ä¸­ç­‰åå‘
        elif total_strength >= 2.5:
            reverse_level = min(3, threshold["level"] + 1)  # å¼±åå‘
        else:
            reverse_level = threshold["level"]
        
        return final_bet_type, reverse_level
    
    return None, 0

# æ ¹æ“šGPUæ¨¡æ“¬çµæœ0.3å¿«é€Ÿåˆ†æè¨­å®šçš„æ–°é–¾é–¾å€¼ - V2.1.1é«˜æ¨è–¦ç‡å„ªåŒ–ç‰ˆ
thresholds_dict = {
    "banker": {
        # æ–°å¢å¯¬é¬†ç´šåˆ¥ - é«˜æ¨è–¦ç‡å„ªåŒ–
        "0": {"min_change": 0.0, "max_change": 0.3, "min_accel": 0.0, "min_prob": 45.0, "level": 1, "win_rate": 50.1},
        "1": {"min_change": 0.0, "max_change": 0.5, "min_accel": 0.0, "min_prob": 45.5, "level": 2, "win_rate": 50.2},
        # æ­£å‘æŒ‡æ¨™ - èŠå®¶ï¼ˆå‹ç‡â‰¥49%ï¼‰
        "2": {"min_change": 0.5, "max_change": 1.0, "min_accel": 0.05, "min_prob": 46.0, "level": 3, "win_rate": 50.3},
        "3": {"min_change": 1.0, "max_change": 1.5, "min_accel": 0.1, "min_prob": 46.5, "level": 4, "win_rate": 50.4},
        "4": {"min_change": 1.5, "max_change": 2.0, "min_accel": 0.15, "min_prob": 47.0, "level": 5, "win_rate": 50.5},
        "5": {"min_change": 2.0, "max_change": 100.0, "min_accel": 0.2, "min_prob": 47.5, "level": 10, "win_rate": 50.6},
        # åå‘æŒ‡æ¨™ - èŠå®¶ï¼ˆå‹ç‡<49%ï¼‰
        "6": {"min_change": 0.0, "max_change": 0.5, "min_accel": 0.0, "min_prob": 44.5, "reverse": True, "level": 1, "win_rate": 48.8},
        "7": {"min_change": 0.5, "max_change": 1.0, "min_accel": 0.05, "min_prob": 45.0, "reverse": True, "level": 1, "win_rate": 48.5}
    },
    "player": {
        # æ–°å¢å¯¬é¬†ç´šåˆ¥ - é«˜æ¨è–¦ç‡å„ªåŒ–
        "0": {"min_change": 0.0, "max_change": 0.3, "min_accel": 0.0, "min_prob": 43.5, "level": 1, "win_rate": 51.5},
        "1": {"min_change": 0.0, "max_change": 0.5, "min_accel": 0.0, "min_prob": 44.0, "level": 2, "win_rate": 51.8},
        # æ­£å‘æŒ‡æ¨™ - é–’å®¶ï¼ˆå‹ç‡â‰¥49%ï¼‰
        "2": {"min_change": 1.0, "max_change": 100.0, "min_accel": 0.05, "min_prob": 44.5, "level": 5, "win_rate": 52.0},
        "3": {"min_change": 1.0, "max_change": 100.0, "min_accel": 0.08, "min_prob": 45.0, "level": 10, "win_rate": 52.2},
        # åå‘æŒ‡æ¨™ - é–’å®¶ï¼ˆå‹ç‡<49%ï¼‰
        "4": {"min_change": 0.0, "max_change": 0.5, "min_accel": 0.0, "min_prob": 43.5, "reverse": True, "level": 1, "win_rate": 49.8},
        "5": {"min_change": 0.5, "max_change": 1.0, "min_accel": 0.05, "min_prob": 44.0, "reverse": True, "level": 1, "win_rate": 49.6},
        "6": {"min_change": 0.0, "max_change": 100.0, "min_accel": 0.0, "min_prob": 45.0, "reverse": True, "level": 1, "win_rate": 46.0},
        "7": {"min_change": 0.0, "max_change": 100.0, "min_accel": 0.0, "min_prob": 45.5, "reverse": True, "level": 1, "win_rate": 43.5}
    },
    "tie": {
        "1": {"min_change": 100.0, "max_change": 0.0, "min_accel": 100.0, "min_prob": 0.0, "level": 0, "win_rate": 0.0},
        "2": {"min_change": 100.0, "max_change": 0.0, "min_accel": 100.0, "min_prob": 0.0, "level": 0, "win_rate": 0.0},
        "3": {"min_change": 100.0, "max_change": 0.0, "min_accel": 100.0, "min_prob": 0.0, "level": 0, "win_rate": 0.0},
        "4": {"min_change": 100.0, "max_change": 0.0, "min_accel": 100.0, "min_prob": 0.0, "level": 0, "win_rate": 0.0},
        "5": {"min_change": 100.0, "max_change": 0.0, "min_accel": 100.0, "min_prob": 0.0, "level": 0, "win_rate": 0.0}
    }
}

# åå‘é–¾é–¾å€¼å­—å…¸ - V2.1.1é«˜æ¨è–¦ç‡å„ªåŒ–ç‰ˆ
reverse_thresholds_dict = {
    "banker": {
        # èŠå®¶éåº¦æ¨‚è§€ -> åå‘ä¸‹æ³¨é–’å®¶ï¼ˆå¤§å¹…æ”¾å¯¬æ¢ä»¶ï¼‰
        "reverse_1": {
            "min_prob": 47.0, "max_prob": 52.0,  # å¾48.0-52.0æ”¾å¯¬åˆ°47.0-52.0
            "min_change": 0.3, "max_change": 100.0,  # å¾0.5é™ä½åˆ°0.3
            "min_accel": -0.25, "max_accel": 0.0,  # å¾-0.3æ”¾å¯¬åˆ°-0.25
            "min_trend_strength": -1.5,  # å¾-2.0æ”¾å¯¬åˆ°-1.5
            "min_cumulative": 1.8,  # å¾2.0é™ä½åˆ°1.8
            "level": 2, "win_rate": 52.5
        },
        "reverse_2": {
            "min_prob": 46.0, "max_prob": 49.0,  # å¾47.0-49.0æ”¾å¯¬åˆ°46.0-49.0
            "min_change": 0.8, "max_change": 100.0,  # å¾1.0é™ä½åˆ°0.8
            "min_accel": -0.18, "max_accel": 0.0,  # å¾-0.2æ”¾å¯¬åˆ°-0.18
            "min_trend_strength": -0.8,  # å¾-1.0æ”¾å¯¬åˆ°-0.8
            "min_cumulative": 1.2,  # å¾1.5é™ä½åˆ°1.2
            "level": 1, "win_rate": 51.0
        }
    },
    "player": {
        # é–’å®¶éåº¦æ¨‚è§€ -> åå‘ä¸‹æ³¨èŠå®¶ï¼ˆå¤§å¹…æ”¾å¯¬æ¢ä»¶ï¼‰
        "reverse_1": {
            "min_prob": 45.0, "max_prob": 50.0,  # å¾46.0-50.0æ”¾å¯¬åˆ°45.0-50.0
            "min_change": 0.3, "max_change": 100.0,  # å¾0.5é™ä½åˆ°0.3
            "min_accel": -0.25, "max_accel": 0.0,  # å¾-0.3æ”¾å¯¬åˆ°-0.25
            "min_trend_strength": -1.5,  # å¾-2.0æ”¾å¯¬åˆ°-1.5
            "min_cumulative": 1.8,  # å¾2.0é™ä½åˆ°1.8
            "level": 2, "win_rate": 53.0
        },
        "reverse_2": {
            "min_prob": 44.0, "max_prob": 47.0,  # å¾45.0-47.0æ”¾å¯¬åˆ°44.0-47.0
            "min_change": 0.8, "max_change": 100.0,  # å¾1.0é™ä½åˆ°0.8
            "min_accel": -0.18, "max_accel": 0.0,  # å¾-0.2æ”¾å¯¬åˆ°-0.18
            "min_trend_strength": -0.8,  # å¾-1.0æ”¾å¯¬åˆ°-0.8
            "min_cumulative": 1.2,  # å¾1.5é™ä½åˆ°1.2
            "level": 1, "win_rate": 51.5
        }
    }
}

card_values = {
    'A': 1, '2': 2, '3': 3, '4': 4, '5': 5, 
    '6': 6, '7': 7, '8': 8, '9': 9, '10': 0, 
    'J': 0, 'Q': 0, 'K': 0
}
card_names = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K']

class BaccaratGPUSimulator:
    def __init__(self):
        global GPU_AVAILABLE
        if GPU_AVAILABLE:
            try:
                self.device = cp.cuda.Device(0)
                self.device.use()
                print(f"âœ“ GPUæ¨¡æ“¬å™¨åˆå§‹åŒ–æˆåŠŸ - v3.8.4é«˜æ¨è–¦ç‡å„ªåŒ–ç³»çµ±")
            except Exception as e:
                print(f"âœ—âœ— GPUè¨­å‚™åˆå§‹åŒ–å¤±æ•—: {e}")
                GPU_AVAILABLE = False
        else:
            print("âœ—âœ— GPUä¸å¯ç”¨ï¼Œä½¿ç”¨CPUæ¨¡æ“¬")
        
        # èˆ‡ä¸»ç¨‹å¼å®Œå…¨ç›¸åŒçš„é…ç½®
        self.base_probabilities = {
            'banker': 45.851, 'player': 44.695, 'tie': 9.454
        }
        self.card_values = card_values
        self.decks = 10
        self.card_names = card_names
        
        # è¶¨å‹¢ç³»çµ±ç‹€æ…‹ï¼ˆèˆ‡ä¸»ç¨‹å¼å®Œå…¨åŒæ­¥ï¼‰- V2.1.1é«˜æ¨è–¦ç‡å„ªåŒ–åƒæ•¸
        self._reset_trend_state()
        
        # èª¿è©¦çµ±è¨ˆ
        self.debug_stats = {
            'total_recommendations': 0,
            'banker_recommendations': 0,
            'player_recommendations': 0,
            'no_recommendations': 0,
            'reverse_recommendations': 0
        }

    def _reset_trend_state(self):
        """é‡ç½®è¶¨å‹¢ç‹€æ…‹ï¼ˆèˆ‡ä¸»ç¨‹å¼ç›¸åŒï¼‰- V2.1.1å„ªåŒ–åƒæ•¸"""
        self.trend_state = {
            'previous_changes': {'banker': 0.0, 'player': 0.0, 'tie': 0.0},
            'trend_strength': {'banker': 0.0, 'player': 0.0, 'tie': 0.0},
            'cumulative_changes': {'banker': 0.0, 'player': 0.0, 'tie': 0.0},
            'consecutive_no_recommendation': 0,
            'change_history': {'banker': [], 'player': [], 'tie': []},
            'trend_decay_counter': {'banker': 0, 'player': 0, 'tie': 0}
        }
def mass_simulation(self, num_simulations=10000):
        """å¤§è¦æ¨¡æ¨¡æ“¬ - v3.8.4é«˜æ¨è–¦ç‡å„ªåŒ–ç‰ˆæœ¬"""
        start_time = time.time()
        
        try:
            # é‡ç½®è¶¨å‹¢ç‹€æ…‹å’Œçµ±è¨ˆ
            self._reset_trend_state()
            self.debug_stats = {
                'total_recommendations': 0,
                'banker_recommendations': 0, 
                'player_recommendations': 0,
                'no_recommendations': 0,
                'reverse_recommendations': 0
            }
            
            if GPU_AVAILABLE:
                results = self._gpu_accelerated_simulation(num_simulations)
            else:
                results = self._cpu_fallback_simulation(num_simulations)
            
            end_time = time.time()
            simulation_time = end_time - start_time
            
            results['performance'] = {
                'total_time': simulation_time,
                'games_per_second': num_simulations / simulation_time,
                'num_simulations': num_simulations
            }
            
            # è¼¸å‡ºèª¿è©¦çµ±è¨ˆ
            total_games = num_simulations
            rec_rate = (self.debug_stats['total_recommendations'] / total_games) * 100
            reverse_rate = (self.debug_stats['reverse_recommendations'] / total_games) * 100
            print(f"âœ“ v3.8.4é«˜æ¨è–¦ç‡æ¨¡æ“¬å®Œæˆ: {num_simulations}å±€")
            print(f"ğŸ“ŠğŸ“Š æ¨è–¦çµ±è¨ˆ: èŠ{self.debug_stats['banker_recommendations']} é–’{self.debug_stats['player_recommendations']} ç„¡{self.debug_stats['no_recommendations']}")
            print(f"ğŸ”„ğŸ”„ åå‘æ¨è–¦: {self.debug_stats['reverse_recommendations']}å±€ ({reverse_rate:.1f}%)")
            rec_rate = (self.debug_stats['total_recommendations'] / num_simulations) * 100
            print(f"ğŸ“ˆğŸ“ˆ æ¨è–¦ç‡: {rec_rate:.1f}% (ç›®æ¨™: 45-65%)")  # âœ…
            
            return results
            
        except Exception as e:
            print(f"âœ—âœ— æ¨¡æ“¬éŒ¯èª¤: {e}")
            return self._cpu_fallback_simulation(num_simulations)
            
        """GPUåŠ é€Ÿæ¨¡æ“¬ - v3.8.4é«˜æ¨è–¦ç‡å„ªåŒ–ç‰ˆ"""
        try:
            # ä½¿ç”¨æ›´å°çš„æ‰¹æ¬¡ç¢ºä¿è¶¨å‹¢é€£çºŒæ€§
            batch_size = min(500, num_simulations)  # âœ… ç»Ÿä¸€å˜é‡å
            results = {
                'banker_wins': 0,
                'player_wins': 0,
                'ties': 0,
                'banker_win_rate': 0.0,
                'player_win_rate': 0.0,
                'tie_rate': 0.0,
                'performance': {},
                'detailed_results': []
            }
            
            # åˆå§‹åŒ–ç‰Œå †å’Œè¶¨å‹¢ç‹€æ…‹
            current_deck = self.initialize_deck_gpu()
            random.shuffle(current_deck)
            
            # ä¿®å¾©ï¼šç›´æ¥å¼•ç”¨ä¸»è¶¨å‹¢ç‹€æ…‹ï¼Œä¸å†è¤‡è£½
            trend_state = self.trend_state
            
            completed_games = 0
            batch_count = 0
            
            while completed_games < num_simulations:
                batch_count += 1
                current_batch_size = min(batch_size, num_simulations - completed_games)
                
                batch_results = self._simulate_batch(current_batch_size, current_deck, trend_state)
                current_deck = batch_results['remaining_deck']
                
                # ä¿®å¾©ï¼šè¶¨å‹¢ç‹€æ…‹å·²åœ¨æ‰¹æ¬¡ä¸­ç›´æ¥æ›´æ–°ï¼Œç„¡éœ€é‡æ–°è³¦å€¼
                # trend_state = batch_results['final_trend_state']
                
                results['banker_wins'] += batch_results['banker_wins']
                results['player_wins'] += batch_results['player_wins']
                results['ties'] += batch_results['ties']
                results['detailed_results'].extend(batch_results['detailed_results'])
                
                completed_games += current_batch_size
                
                # é€²åº¦è¼¸å‡º
                if batch_count % 10 == 0:
                    progress = (completed_games / num_simulations) * 100
                    print(f"ğŸ”„ğŸ”„ GPUæ¨¡æ“¬é€²åº¦: {completed_games}/{num_simulations} ({progress:.1f}%)")
                
                # é‡‹æ”¾GPUå…§å­˜
                if GPU_AVAILABLE:
                    cp.get_default_memory_pool().free_all_blocks()
            
            total_games = num_simulations
            results['banker_win_rate'] = results['banker_wins'] / total_games * 100
            results['player_win_rate'] = results['player_wins'] / total_games * 100
            results['tie_rate'] = results['ties'] / total_games * 100
            
            return results
            
        except Exception as e:
            print(f"âœ—âœ— GPUæ¨¡æ“¬éŒ¯èª¤: {e}")
            raise

def _simulate_batch(self, batch_size, current_deck, trend_state):
        """æ‰¹æ¬¡æ¨¡æ“¬ - è¿”å›æœ€çµ‚è¶¨å‹¢ç‹€æ…‹"""
        banker_wins = 0
        player_wins = 0
        ties = 0
        detailed_results = []
        
        for i in range(batch_size):
            result = self._simulate_single_game_cpu(i, current_deck, trend_state)
            current_deck = result['remaining_deck']
            # trend_state åœ¨ _simulate_single_game_cpu ä¸­å·²ç¶“è¢«æ›´æ–°
            
            if result['winner'] == 'banker':
                banker_wins += 1
            elif result['winner'] == 'player':
                player_wins += 1
            else:
                ties += 1
            
            detailed_results.append(result)
            
            # æ›´æ–°èª¿è©¦çµ±è¨ˆ
            if result['recommendation']:
                self.debug_stats['total_recommendations'] += 1
                if result['recommendation'] == 'banker':
                    self.debug_stats['banker_recommendations'] += 1
                else:
                    self.debug_stats['player_recommendations'] += 1
                
                # æª¢æŸ¥æ˜¯å¦ç‚ºåå‘æ¨è–¦
                if result.get('is_reverse', False):
                    self.debug_stats['reverse_recommendations'] += 1
            else:
                self.debug_stats['no_recommendations'] += 1
        
        return {
            'banker_wins': banker_wins,
            'player_wins': player_wins,
            'ties': ties,
            'detailed_results': detailed_results,
            'remaining_deck': current_deck,
            'final_trend_state': trend_state  # è¿”å›æœ€çµ‚è¶¨å‹¢ç‹€æ…‹
        }

def _simulate_single_game_cpu(self, game_id, remaining_deck, trend_state):
        """å–®å±€æ¨¡æ“¬ - å®Œå…¨è¤‡è£½CPUé‚è¼¯"""
        # ç‰Œå †ç®¡ç†ï¼ˆèˆ‡CPUç›¸åŒï¼‰
        if remaining_deck is None or len(remaining_deck) < 6:
            deck = self.initialize_deck_gpu()
            random.shuffle(deck)
        else:
            deck = remaining_deck.copy()
        
        # æ¨¡æ“¬ç‰Œå±€ï¼ˆèˆ‡CPUå®Œå…¨ç›¸åŒï¼‰
        player_hand = [deck.pop(0), deck.pop(0)]
        banker_hand = [deck.pop(0), deck.pop(0)]
        
        player_score = sum(self.card_values[card] for card in player_hand) % 10
        banker_score = sum(self.card_values[card] for card in banker_hand) % 10
        
        player_drew = False
        player_third_card_value = None
        
        # ç©å®¶æŠ½ç‰Œè¦å‰‡ï¼ˆèˆ‡ä¸»ç¨‹å¼ç›¸åŒï¼‰
        if player_score <= 5:
            if len(deck) > 0:
                player_third_card = deck.pop(0)
                player_hand.append(player_third_card)
                player_score = sum(self.card_values[card] for card in player_hand) % 10
                player_drew = True
                player_third_card_value = self.card_values[player_third_card]
        
        # èŠå®¶æŠ½ç‰Œè¦å‰‡ï¼ˆèˆ‡ä¸»ç¨‹å¼ç›¸åŒï¼‰
        if banker_score <= 2:
            if len(deck) > 0:
                banker_third_card = deck.pop(0)
                banker_hand.append(banker_third_card)
                banker_score = sum(self.card_values[card] for card in banker_hand) % 10
        elif banker_score == 3 and player_drew and player_third_card_value != 8:
            if len(deck) > 0:
                banker_third_card = deck.pop(0)
                banker_hand.append(banker_third_card)
                banker_score = sum(self.card_values[card] for card in banker_hand) % 10
        elif banker_score == 4 and player_drew and player_third_card_value in [2,3,4,5,6,7]:
            if len(deck) > 0:
                banker_third_card = deck.pop(0)
                banker_hand.append(banker_third_card)
                banker_score = sum(self.card_values[card] for card in banker_hand) % 10
        elif banker_score == 5 and player_drew and player_third_card_value in [4,5,6,7]:
            if len(deck) > 0:
                banker_third_card = deck.pop(0)
                banker_hand.append(banker_third_card)
                banker_score = sum(self.card_values[card] for card in banker_hand) % 10
        elif banker_score == 6 and player_drew and player_third_card_value in [6,7]:
            if len(deck) > 0:
                banker_third_card = deck.pop(0)
                banker_hand.append(banker_third_card)
                banker_score = sum(self.card_values[card] for card in banker_hand) % 10
        
        # è¨ˆç®—å‹è² 
        if banker_score > player_score:
            winner = 'banker'
            winner_chinese = 'èŠ'
        elif player_score > banker_score:
            winner = 'player'
            winner_chinese = 'é–’'
        else:
            winner = 'tie'
            winner_chinese = 'å’Œ'
        
        # è¨ˆç®—çœŸå¯¦æ¦‚ç‡ï¼ˆèˆ‡CPUç›¸åŒï¼‰
        probabilities = self._calculate_probabilities_from_deck(deck)
        
        # ä½¿ç”¨å®Œå…¨ç›¸åŒçš„æ¨è–¦é‚è¼¯ï¼ˆåŒ…å«ç²¾æº–åå‘é‚è¼¯ï¼‰
        recommendation, bet_level, is_reverse = self._get_recommendation_with_main_logic(
            probabilities, 
            trend_state
        )
        
        # æ›´æ–°è¶¨å‹¢ç‹€æ…‹ï¼ˆèˆ‡CPUç›¸åŒï¼‰
        self._update_trend_state(trend_state, probabilities, recommendation)
        
        # ç”Ÿæˆçµæœ
        result_text = self._generate_result_text(recommendation, winner, winner_chinese, is_reverse)
        
        return {
            'game_id': game_id,
            'banker_hand': banker_hand,
            'player_hand': player_hand,
            'banker_score': banker_score,
            'player_score': player_score,
            'winner': winner,
            'winner_chinese': winner_chinese,
            'probabilities': probabilities,
            'recommendation': recommendation,
            'bet_level': bet_level,
            'is_reverse': is_reverse,
            'result_text': result_text,
            'result': 'âœ“' if recommendation == winner else 'âœ—âœ—' if recommendation else 'ç„¡',
            'remaining_deck': deck,
            'changes': self._calculate_changes(probabilities),
            'trend_state': trend_state
        }

def _calculate_probabilities_from_deck(self, deck):
        """è¨ˆç®—åŸºæ–¼å‰©é¤˜ç‰Œå †çš„çœŸå¯¦æ¦‚ç‡ï¼ˆèˆ‡ä¸»ç¨‹å¼å®Œå…¨ä¸€è‡´ï¼‰"""
        total_cards = len(deck)
        total_initial_cards = self.decks * 52
        
        if total_cards < 20:  # èˆ‡ä¸»ç¨‹å¼ç›¸åŒçš„é‡æ–°æ´—ç‰Œæ¢ä»¶
            return self.base_probabilities.copy()
        
        # è¨ˆç®—å„é»æ•¸ç‰Œçš„æ•¸é‡ï¼ˆèˆ‡ä¸»ç¨‹å¼ç›¸åŒï¼‰
        card_counts = {}
        for card in self.card_names:
            count = deck.count(card)
            card_counts[card] = count
        
        point_ratios = {}
        for point in range(0, 10):
            if point == 0:
                cards_for_point = ['10', 'J', 'Q', 'K']
            else:
                cards_for_point = [card for card in self.card_names if self.card_values[card] == point]
            
            total_count = sum(card_counts[card] for card in cards_for_point)
            point_ratios[point] = total_count / total_cards
        
        # èˆ‡ä¸»ç¨‹å¼å®Œå…¨ç›¸åŒçš„èª¿æ•´å…¬å¼
        high_card_ratio = point_ratios[0]
        low_card_ratio = sum(point_ratios[i] for i in [1, 2, 3, 4, 5])
        medium_card_ratio = sum(point_ratios[i] for i in [6, 7])
        eight_nine_ratio = sum(point_ratios[i] for i in [8, 9])
        
        banker_adjust = (eight_nine_ratio - 0.158) * 8 - (low_card_ratio - 0.385) * 4
        player_adjust = (low_card_ratio - 0.385) * 8 - (eight_nine_ratio - 0.158) * 4
        tie_adjust = (medium_card_ratio - 0.308) * 6
        
        # æ¶ˆè€—æ•ˆæ‡‰ï¼ˆèˆ‡ä¸»ç¨‹å¼ç›¸åŒï¼‰
        consumption_ratio = (total_initial_cards - total_cards) / total_initial_cards
        consumption_effect = consumption_ratio * 2
        
        # èˆ‡ä¸»ç¨‹å¼ç›¸åŒçš„æ¦‚ç‡è¨ˆç®—
        probabilities = {
            'banker': max(40.0, min(52.0, self.base_probabilities['banker'] + banker_adjust + consumption_effect)),
            'player': max(40.0, min(52.0, self.base_probabilities['player'] + player_adjust - consumption_effect)),
            'tie': max(5.0, min(15.0, self.base_probabilities['tie'] + tie_adjust))
        }
        
        # æ­£è¦åŒ–ï¼ˆèˆ‡ä¸»ç¨‹å¼ç›¸åŒï¼‰
        total = sum(probabilities.values())
        if total > 0:
            scale = 100.0 / total
            for key in probabilities:
                probabilities[key] = round(probabilities[key] * scale, 3)
        
        return probabilities

def _get_recommendation_with_main_logic(self, probabilities, trend_state):
        """å®Œå…¨è¤‡è£½ä¸»ç¨‹å¼çš„æ¨è–¦é‚è¼¯ï¼ˆåŒ…å«ç²¾æº–åå‘é‚è¼¯ï¼‰"""
        banker_prob = probabilities['banker']
        player_prob = probabilities['player']
        
        # è¨ˆç®—è®ŠåŒ–ç‡ï¼ˆèˆ‡ä¸»ç¨‹å¼å®Œå…¨ç›¸åŒï¼‰
        base_probs = self.base_probabilities
        banker_change = ((banker_prob - base_probs['banker']) / base_probs['banker']) * 100
        player_change = ((player_prob - base_probs['player']) / base_probs['player']) * 100
        
        # è¨ˆç®—åŠ é€Ÿï¼ˆèˆ‡ä¸»ç¨‹å¼å®Œå…¨ç›¸åŒï¼‰
        previous_changes = trend_state['previous_changes']
        banker_acceleration = banker_change - previous_changes['banker']
        player_acceleration = player_change - previous_changes['player']
        
        # èŠå®¶æ¨è–¦åˆ¤æ–·ï¼ˆå®Œå…¨è¤‡è£½ä¸»ç¨‹å¼é‚è¼¯ + ç²¾æº–åå‘é‚è¼¯ï¼‰
        banker_recommendation = self._evaluate_bet_recommendation(
            'banker', banker_prob, banker_change, banker_acceleration, trend_state
        )
        
        # é–’å®¶æ¨è–¦åˆ¤æ–·ï¼ˆå®Œå…¨è¤‡è£½ä¸»ç¨‹å¼é‚è¼¯ + ç²¾æº–åå‘é‚è¼¯ï¼‰
        player_recommendation = self._evaluate_bet_recommendation(
            'player', player_prob, player_change, player_acceleration, trend_state
        )
        
        # é¸æ“‡æœ€ä½³æ¨è–¦ï¼ˆèˆ‡ä¸»ç¨‹å¼ç›¸åŒï¼‰
        recommendations = []
        if banker_recommendation and banker_recommendation['level'] > 0:
            recommendations.append(banker_recommendation)
        if player_recommendation and player_recommendation['level'] > 0:
            recommendations.append(player_recommendation)
        
        if recommendations:
            recommendations.sort(key=lambda x: (x['level'], abs(trend_state['trend_strength'][x['bet_type']])), reverse=True)
            best_rec = recommendations[0]
            return best_rec['bet_type'], best_rec['level'], best_rec.get('is_reverse', False)
        else:
            return None, 0, False

def _evaluate_bet_recommendation(self, bet_type, current_prob, percentage_change, acceleration, trend_state):
        """è©•ä¼°ä¸‹æ³¨æ¨è–¦ï¼ˆå®Œå…¨è¤‡è£½ä¸»ç¨‹å¼é‚è¼¯ + ç²¾æº–åå‘é‚è¼¯ï¼‰- V2.1.1é«˜æ¨è–¦ç‡å„ªåŒ–"""
        if bet_type not in thresholds_dict:
            return None
        
        # å‹•æ…‹åŠ é€Ÿé–¾é–¾å€¼ï¼ˆèˆ‡ä¸»ç¨‹å¼ç›¸åŒï¼‰- V2.1.1å„ªåŒ–
        base_threshold = 0.01  # å¾0.05é™ä½åˆ°0.01ï¼ˆé«˜æ¨è–¦ç‡å„ªåŒ–ï¼‰
        consecutive_no_recommendation = trend_state['consecutive_no_recommendation']
        
        if consecutive_no_recommendation >= 15:  # å¾10å¢åŠ åˆ°15ï¼ˆæ”¾å¯¬æ‡²ç½°ï¼‰
            current_accel_threshold = base_threshold * 0.8  # å¾0.5å¢åŠ åˆ°0.8
        elif consecutive_no_recommendation >= 10:  # å¾6å¢åŠ åˆ°10
            current_accel_threshold = base_threshold * 0.9  # å¾0.7å¢åŠ åˆ°0.9
        elif consecutive_no_recommendation >= 5:   # å¾3å¢åŠ åˆ°5
            current_accel_threshold = base_threshold * 0.95  # å¾0.85å¢åŠ åˆ°0.95
        else:
            current_accel_threshold = base_threshold
        
        # è¶¨å‹¢éæ¿¾ï¼ˆèˆ‡ä¸»ç¨‹å¼ç›¸åŒï¼‰- V2.1.1å¤§å¹…æ”¾å¯¬
        if abs(trend_state['trend_strength'][bet_type]) < 0.0001:  # å¾0.0001ä¿æŒä¸è®Š
            return None
        
        final_bet_type = bet_type
        cumulative_bonus = 0
        is_reverse = False
        
        # V2.1.1å„ªåŒ–ï¼šå¤§å¹…é™ä½ç´¯ç©è®ŠåŒ–çå‹µé–€æª»
        if abs(trend_state['cumulative_changes'][bet_type]) > 0.3:  # å¾0.5é™ä½åˆ°0.3
            cumulative_bonus = min(3, int(abs(trend_state['cumulative_changes'][bet_type]) * 3))  # çå‹µå¢åŠ 
        
        # é¦–å…ˆæª¢æŸ¥ç²¾æº–åå‘é‚è¼¯
        reverse_bet, reverse_level = improved_reverse_evaluation_full(
            bet_type, current_prob, percentage_change, acceleration, 
            trend_state, reverse_thresholds_dict[bet_type].get("reverse_1", {})
        )
        
        if reverse_bet and reverse_level > 0:
            final_bet_type = reverse_bet
            base_level = reverse_level
            is_reverse = True
        else:
            # åŸæœ‰é–¾é–¾å€¼åˆ¤æ–·é‚è¼¯ï¼ˆèˆ‡ä¸»ç¨‹å¼å®Œå…¨ç›¸åŒï¼‰- V2.1.1æ–°å¢å¯¬é¬†ç´šåˆ¥
            for level in ['7', '6', '5', '4', '3', '2', '1', '0']:  # æ–°å¢'0'ç´šåˆ¥
                if level in thresholds_dict[bet_type]:
                    threshold = thresholds_dict[bet_type][level]
                    
                    if current_prob < threshold.get("min_prob", 0):
                        continue
                    
                    if (threshold["min_change"] <= abs(percentage_change) < threshold["max_change"] and 
                        acceleration >= threshold["min_accel"]):
                        
                        base_level = threshold["level"]
                        
                        if threshold.get("reverse", False) or threshold.get("win_rate", 50) < 49:
                            final_bet_type = 'player' if bet_type == 'banker' else 'banker'
                            base_level = 1
                            is_reverse = True
                        
                        if not threshold.get("reverse", False) and threshold.get("win_rate", 50) >= 49:
                            final_level = min(20, base_level + cumulative_bonus)
                        else:
                            final_level = base_level
                        
                        return {
                            'bet_type': final_bet_type,
                            'level': final_level,
                            'is_reverse': is_reverse
                        }
            
            return None
        
        # åå‘é‚è¼¯çš„ç­‰ç´šè¨ˆç®—
        if is_reverse:
            reverse_level_adjusted = get_reverse_bet_level(
                bet_type, current_prob, percentage_change, acceleration, trend_state
            )
            final_level = max(1, min(5, base_level + reverse_level_adjusted))
            
            return {
                'bet_type': final_bet_type,
                'level': final_level,
                'is_reverse': is_reverse
            }
        
        return None

def _update_trend_state(self, trend_state, probabilities, recommendation):
        """æ›´æ–°è¶¨å‹¢ç‹€æ…‹ï¼ˆèˆ‡ä¸»ç¨‹å¼å®Œå…¨ç›¸åŒï¼‰- V2.1.1é«˜æ¨è–¦ç‡å„ªåŒ–"""
        # è¨ˆç®—è®ŠåŒ–ç‡
        current_changes = {}
        for bet_type in ['banker', 'player', 'tie']:
            current_prob = probabilities[bet_type]
            base_prob = self.base_probabilities[bet_type]
            current_changes[bet_type] = ((current_prob - base_prob) / base_prob) * 100
        
        # æ›´æ–°è¶¨å‹¢å¼·åº¦ï¼ˆèˆ‡ä¸»ç¨‹å¼ç›¸åŒçš„è¤‡é›œé‚è¼¯ï¼‰- V2.1.1å„ªåŒ–
        for bet_type in ['banker', 'player']:
            current_change = current_changes[bet_type]
            previous_change = trend_state['previous_changes'][bet_type]
            acceleration = current_change - previous_change
            
            # å®Œå…¨è¤‡è£½CPUçš„è¶¨å‹¢æ›´æ–°é‚è¼¯ - V2.1.1å¤§å¹…å„ªåŒ–
            current_strength = trend_state['trend_strength'][bet_type]
            
            # V2.1.1å„ªåŒ–ï¼šå¤§å¹…é™ä½åŠ é€Ÿè§¸ç™¼é–€æª»
            if acceleration > 0.01:  # åŠ é€Ÿé–¾é–¾å€¼å¾0.05é™ä½åˆ°0.01
                strength_increment = max(0.02, min(3.0, abs(acceleration) * 0.8))  # ä¹˜æ•¸å¾0.5å¢åŠ åˆ°0.8
                if current_strength > 12.0:  # å¾8.0å¢åŠ åˆ°12.0
                    strength_increment *= 0.8  # å¾0.6å¢åŠ åˆ°0.8
                elif current_strength > 8.0:   # å¾5.0å¢åŠ åˆ°8.0
                    strength_increment *= 0.9  # å¾0.8å¢åŠ åˆ°0.9
                trend_state['trend_strength'][bet_type] = min(25.0, current_strength + strength_increment)  # å¾15.0å¢åŠ åˆ°25.0
                trend_state['trend_decay_counter'][bet_type] = 0
            elif acceleration < -0.01:  # åŠ é€Ÿé–¾é–¾å€¼å¾0.05é™ä½åˆ°0.01
                strength_decrement = max(0.02, min(3.0, abs(acceleration) * 0.8))  # ä¹˜æ•¸å¾0.5å¢åŠ åˆ°0.8
                trend_state['trend_strength'][bet_type] = max(-25.0, current_strength - strength_decrement)  # å¾15.0å¢åŠ åˆ°25.0
                trend_state['trend_decay_counter'][bet_type] = 0
            else:
                trend_state['trend_decay_counter'][bet_type] += 1
                
                # è¡°æ¸›é‚è¼¯ï¼ˆèˆ‡CPUç›¸åŒï¼‰- V2.1.1å„ªåŒ–
                decay_rate = 0.02  # å¾0.03é™ä½åˆ°0.02
                if abs(current_strength) > 15.0:  # å¾10.0å¢åŠ åˆ°15.0
                    decay_rate = 0.10  # å¾0.12é™ä½åˆ°0.10
                elif abs(current_strength) > 10.0:  # å¾6.0å¢åŠ åˆ°10.0
                    decay_rate = 0.06  # å¾0.08é™ä½åˆ°0.06
                elif abs(current_strength) > 5.0:   # å¾3.0å¢åŠ åˆ°5.0
                    decay_rate = 0.04  # å¾0.05é™ä½åˆ°0.04
                    
                decay_multiplier = min(2.0, 1.0 + (trend_state['trend_decay_counter'][bet_type] * 0.05))  # ä¹˜æ•¸å¾0.08é™ä½åˆ°0.05
                decay_rate *= decay_multiplier
                
                if current_strength > 0:
                    trend_state['trend_strength'][bet_type] = max(0, current_strength - decay_rate)
                elif current_strength < 0:
                    trend_state['trend_strength'][bet_type] = min(0, current_strength + decay_rate)
            
            # ç´¯ç©è®ŠåŒ–ï¼ˆèˆ‡CPUç›¸åŒï¼‰- V2.1.1å„ªåŒ–
            cumulative_effect = current_change * 0.04  # å¾0.03å¢åŠ åˆ°0.04
            trend_state['cumulative_changes'][bet_type] += cumulative_effect
            trend_state['cumulative_changes'][bet_type] = max(-12.0, min(12.0, trend_state['cumulative_changes'][bet_type]))  # å¾8.0å¢åŠ åˆ°12.0
            
            # æ›´æ–°è®ŠåŒ–æ­·å²
            trend_state['change_history'][bet_type].append(current_change)
            if len(trend_state['change_history'][bet_type]) > 5:
                trend_state['change_history'][bet_type].pop(0)
        
        # æ›´æ–°é€£çºŒç„¡æ¨è–¦è¨ˆæ•¸
        if recommendation is None:
            trend_state['consecutive_no_recommendation'] += 1
        else:
            trend_state['consecutive_no_recommendation'] = 0
        
        # æ›´æ–°å…ˆå‰è®ŠåŒ–
        trend_state['previous_changes'] = current_changes

def _generate_result_text(self, recommendation, winner, winner_chinese, is_reverse=False):
        """ç”Ÿæˆçµæœæ–‡æœ¬"""
        if recommendation:
            chinese_name = 'èŠ' if recommendation == 'banker' else 'é–’'
            result = 'âœ“' if recommendation == winner else 'âœ—âœ—'
            reverse_indicator = "ğŸ”„ğŸ”„" if is_reverse else ""
            return f"ï¼Œæ¨è–¦{reverse_indicator}({chinese_name})ï¼Œ{winner_chinese}è´ {result}"
        else:
            return "ï¼Œç„¡æ¨è–¦"

def _calculate_changes(self, probabilities):
        """è¨ˆç®—è®ŠåŒ–ç‡ï¼ˆèˆ‡ä¸»ç¨‹å¼ç›¸åŒï¼‰"""
        changes = {}
        for key in probabilities:
            changes[key] = ((probabilities[key] - self.base_probabilities[key]) / self.base_probabilities[key]) * 100
        return changes

def _cpu_fallback_simulation(self, num_simulations):
        """CPUå›é€€æ¨¡æ“¬"""
        print("ä½¿ç”¨CPUé€²è¡Œæ¨¡æ“¬...")
        start_time = time.time()
        
        results = {
            'banker_wins': 0,
            'player_wins': 0,
            'ties': 0,
            'detailed_results': []
        }
        
        # ä½¿ç”¨çµ±ä¸€çš„ç‰Œå †ç®¡ç†å’Œè¶¨å‹¢ç‹€æ…‹
        current_deck = self.initialize_deck_gpu()
        random.shuffle(current_deck)
        current_trend_state = self.trend_state
        
        for i in range(num_simulations):
            result = self._simulate_single_game_cpu(i, current_deck, current_trend_state)
            current_deck = result['remaining_deck']
            
            if result['winner'] == 'banker':
                results['banker_wins'] += 1
            elif result['winner'] == 'player':
                results['player_wins'] += 1
            else:
                results['ties'] += 1
            
            results['detailed_results'].append(result)
        
        total_games = num_simulations
        results['banker_win_rate'] = results['banker_wins'] / total_games * 100
        results['player_win_rate'] = results['player_wins'] / total_games * 100
        results['tie_rate'] = results['ties'] / total_games * 100
        
        end_time = time.time()
        results['performance'] = {
            'total_time': end_time - start_time,
            'games_per_second': num_simulations / (end_time - start_time),
            'batch_size': 1
        }
        
        return results

def initialize_deck_gpu(self):
        """åˆå§‹åŒ–ç‰Œå †ï¼ˆèˆ‡ä¸»ç¨‹å¼ç›¸åŒï¼‰"""
        deck = []
        for _ in range(self.decks):
            for card in self.card_names:
                deck.extend([card] * 4)
        return deck

# æ ¸å¿ƒç®—æ³•ç±»ç»“æŸ
# ç¬¬ä¸‰éƒ¨åˆ†ï¼šGUIç•Œé¢ç±» - v3.8.4é«˜æ¨è–¦ç‡å„ªåŒ–ç‰ˆ

class BaccaratAIAssistant:
    def __init__(self, root):
        self.root = root
        self.root.title("ç™¾å®¶æ¨‚ AI ç®—ç‰Œé æ¸¬ v3.8.4 - GPU-DP-V2.1.1ï¼ˆé«˜æ¨è–¦ç‡å„ªåŒ–ç‰ˆï¼‰")
        self.root.geometry("1200x800")
        self.root.configure(bg='#1a1a1a')
        
        # GPU ç›¸é—œåˆå§‹åŒ–
        self.gpu_enabled = GPU_AVAILABLE
        self.gpu_simulator = None
        if self.gpu_enabled:
            try:
                self.gpu_simulator = BaccaratGPUSimulator()
                print("âœ“ GPUæ¨¡æ“¬å™¨åˆå§‹åŒ–æˆåŠŸ - v3.8.4é«˜æ¨è–¦ç‡å„ªåŒ–ç³»çµ±")
            except Exception as e:
                print(f"âœ—âœ— GPUæ¨¡æ“¬å™¨åˆå§‹åŒ–å¤±æ•—: {e}")
                self.gpu_enabled = False
        else:
            print("âœ—âœ— GPUä¸å¯ç”¨ï¼Œä½¿ç”¨CPUæ¨¡æ“¬")
        
        # åˆå§‹åŒ–æ•¸æ“š
        self.game_count = 1
        self.a_count = 0
        self.decks = 10
        self.simulation_running = False
        self.simulation_stop_flag = False
        self.export_path = os.getcwd()
        
        # è¶¨å‹¢åŠ é€Ÿç›¸é—œè®Šé‡ï¼ˆèˆ‡GPUæ¨¡æ“¬å™¨å®Œå…¨ä¸€è‡´ï¼‰- V2.1.1é«˜æ¨è–¦ç‡å„ªåŒ–åƒæ•¸
        self.previous_changes = {
            'banker': 0.0,
            'player': 0.0, 
            'tie': 0.0
        }
        self.trend_strength = {
            'banker': 0.0,
            'player': 0.0,
            'tie': 0.0
        }
        self.consecutive_no_recommendation = 0
        
        # è¶¨å‹¢éæ¿¾åƒæ•¸ - V2.1.1å¤§å¹…å„ªåŒ–ï¼ˆé«˜æ¨è–¦ç‡ï¼‰
        self.trend_filter_enabled = True
        self.min_trend_strength = 0.0001  # å¾0.01å¤§å¹…é™ä½åˆ°0.0001
        self.acceleration_threshold = 0.01  # å¾0.05é™ä½åˆ°0.01
        self.max_trend_strength = 25.0  # å¾15.0å¢åŠ åˆ°25.0
        
        # ç´¯ç©è®ŠåŒ–ç‡ç³»çµ±ï¼ˆèˆ‡GPUæ¨¡æ“¬å™¨ä¸€è‡´ï¼‰- V2.1.1å¤§å¹…æ”¾å¯¬
        self.cumulative_changes = {
            'banker': 0.0,
            'player': 0.0,
            'tie': 0.0
        }
        self.max_cumulative_change = 12.0  # å¾8.0å¢åŠ åˆ°12.0
        self.change_history = {
            'banker': [],
            'player': [],
            'tie': []
        }
        
        # è¶¨å‹¢å¼·åº¦è¡°æ¸›è¨ˆæ•¸å™¨ï¼ˆèˆ‡GPUæ¨¡æ“¬å™¨ä¸€è‡´ï¼‰- V2.1.1å„ªåŒ–
        self.trend_decay_counter = {
            'banker': 0,
            'player': 0,
            'tie': 0
        }
        self.base_decay_rate = 0.02  # å¾0.03é™ä½åˆ°0.02
        
        self.current_cards = []
        self.manual_threshold_set = False
        
        # ç­–ç•¥åƒæ•¸ - å°ˆæ³¨èŠé–’
        self.observe_bp = True
        self.observe_tie = False
        self.observe_pair = False
        self.observe_big_small = False
        
        # æ¨è–¦é–¾é–¾å€¼åƒæ•¸
        self.THRESHOLD_min_games = 1
        self.THRESHOLD_max_games = 100
        self.threshold_group = "standard"
        
        # åŸºç¤æ¦‚ç‡
        self.base_probabilities = {
            'banker': 45.851,
            'player': 44.695,
            'tie': 9.454,
            'banker_pair': 14.642,
            'player_pair': 14.642,
            'big': 62.113,
            'small': 37.887,
            'lucky_six': 8.331
        }
        
        # è³ ç‡è¨­å®š
        self.payouts = {
            'banker': 0.95,
            'player': 1.0,
            'tie': 8.0,
            'banker_pair': 11.0,
            'player_pair': 11.0,
            'big': 1.5,
            'small': 1.5,
            'lucky_six': 12.0
        }
        
        self.current_probs = self.base_probabilities.copy()
        self.history = []
        self.card_count = defaultdict(int)
        self.remaining_deck = self.initialize_deck(self.decks)
        
        self.recommendation_stats = {
            'banker': {'bet': 0, 'win': 0, 'amount': 0},
            'player': {'bet': 0, 'win': 0, 'amount': 0},
            'tie': {'bet': 0, 'win': 0, 'amount': 0}
        }
        
        self.current_result = ""
        self.current_recommendation_snapshot = None
        self.auto_sim_results = []
        
        # GPUæ¨¡æ“¬çµæœå­˜å„²
        self.gpu_simulation_history = []
        self.gpu_detailed_results = []
        
        # é«˜æ¨è–¦ç‡æ¨¡å¼æ¨™èªŒ
        self.high_recommendation_mode = True
        
        self.setup_ui()
        self.update_probabilities_display_only()

    def enable_high_recommendation_mode(self):
        """å•Ÿç”¨é«˜æ¨è–¦ç‡æ¨¡å¼ - V2.1.1æ ¸å¿ƒåŠŸèƒ½"""
        self.min_trend_strength = 0.0001
        self.acceleration_threshold = 0.005  # æ¥µä½é–¾å€¼
        self.max_trend_strength = 30.0
        self.max_cumulative_change = 15.0
        self.base_decay_rate = 0.01
        
        # ç¦ç”¨é€£çºŒç„¡æ¨è–¦æ‡²ç½°
        self.consecutive_no_recommendation = 0
        
        # æ›´æ–°UIé¡¯ç¤º
        self.min_trend_var.set("0.0001")
        self.data_status_label.config(text="âœ… é«˜æ¨è–¦ç‡æ¨¡å¼å·²å•Ÿç”¨ - ç›®æ¨™æ¨è–¦ç‡: 45-65%", fg='#00ff00')
        
        print("âœ… é«˜æ¨è–¦ç‡æ¨¡å¼å·²å•Ÿç”¨ - ç›®æ¨™æ¨è–¦ç‡: 45-65%")
        messagebox.showinfo("é«˜æ¨è–¦ç‡æ¨¡å¼", "âœ… é«˜æ¨è–¦ç‡æ¨¡å¼å·²å•Ÿç”¨ï¼\nç›®æ¨™æ¨è–¦ç‡: 45-65%\nåå‘æ¨è–¦æ¯”ä¾‹: 15-25%")

    def toggle_trend_filter(self):
        self.trend_filter_enabled = self.trend_filter_var.get()
        status = "å•Ÿç”¨" if self.trend_filter_enabled else "ç¦ç”¨"
        self.data_status_label.config(text=f"v3.8.4é«˜æ¨è–¦ç‡ç³»çµ±{status} - æœ€å°å¼·åº¦:{self.min_trend_strength}", fg='#00ff00')

    def update_trend_settings(self):
        try:
            self.min_trend_strength = float(self.min_trend_var.get())
            self.toggle_trend_filter()
        except ValueError:
            pass

    def update_thresholds(self):
        try:
            self.THRESHOLD_min_games = int(self.min_games_var.get())
            self.THRESHOLD_max_games = int(self.max_games_var.get())
            
            if self.THRESHOLD_min_games >= self.THRESHOLD_max_games:
                self.THRESHOLD_max_games = self.THRESHOLD_min_games + 10
                self.max_games_var.set(str(self.THRESHOLD_max_games))
                
            gpu_status = " | GPUåŠ é€Ÿ: å¯ç”¨" if self.gpu_enabled else " | GPUåŠ é€Ÿ: ä¸å¯ç”¨"
            self.status_label.config(text=f"å±€æ•¸ï¼š#{self.game_count} | Aç‰Œï¼š{self.a_count} | å‰©é¤˜ç‰Œï¼š{len(self.remaining_deck)} | æ¨è–¦ç¯„åœï¼š{self.THRESHOLD_min_games}-{self.THRESHOLD_max_games}å±€{gpu_status}")
            self.update_recommendation_display()
            
        except ValueError:
            pass

    def initialize_deck(self, num_decks=10):
        deck = []
        for _ in range(num_decks):
            for card in card_names:
                deck.extend([card] * 4)
        random.shuffle(deck)
        return deck

    def calculate_baccarat_score(self, hand):
        return sum(card_values[card] for card in hand) % 10

    def should_player_draw(self, player_score, banker_score):
        if player_score >= 8 or banker_score >= 8:
            return False
        return player_score < 6

    def should_banker_draw(self, banker_score, player_score, player_drew, player_third_card_value=None):
        if player_score >= 8 or banker_score >= 8:
            return False
            
        if not player_drew:
            return banker_score < 6
        else:
            if banker_score <= 2:
                return True
            elif banker_score == 3:
                return player_third_card_value != 8
            elif banker_score == 4:
                return player_third_card_value in [2, 3, 4, 5, 6, 7]
            elif banker_score == 5:
                return player_third_card_value in [4, 5, 6, 7]
            elif banker_score == 6:
                return player_third_card_value in [6, 7]
            else:
                return False

    def simulate_baccarat_round(self, input_cards=None):
        if len(self.remaining_deck) < 6:
            self.remaining_deck = self.initialize_deck(self.decks)
            print("ç‰Œå †ä¸è¶³ï¼Œé‡æ–°æ´—ç‰Œ")
        
        if input_cards and len(input_cards) >= 4:
            player_hand = [input_cards[0], input_cards[1]]
            banker_hand = [input_cards[2], input_cards[3]]
            
            for card in input_cards[:4]:
                if card in self.remaining_deck:
                    self.remaining_deck.remove(card)
        else:
            player_hand = [self.remaining_deck.pop(0), self.remaining_deck.pop(0)]
            banker_hand = [self.remaining_deck.pop(0), self.remaining_deck.pop(0)]
        
        player_score = self.calculate_baccarat_score(player_hand)
        banker_score = self.calculate_baccarat_score(banker_hand)
        
        player_drew = False
        player_third_card_value = None
        
        if self.should_player_draw(player_score, banker_score):
            if input_cards and len(input_cards) >= 5:
                player_third_card = input_cards[4]
                if player_third_card in self.remaining_deck:
                    self.remaining_deck.remove(player_third_card)
            else:
                player_third_card = self.remaining_deck.pop(0)
                
            player_hand.append(player_third_card)
            player_score = self.calculate_baccarat_score(player_hand)
            player_drew = True
            player_third_card_value = card_values[player_third_card]
        
        if self.should_banker_draw(banker_score, player_score, player_drew, player_third_card_value):
            if input_cards and len(input_cards) >= 6:
                banker_third_card = input_cards[5]
                if banker_third_card in self.remaining_deck:
                    self.remaining_deck.remove(banker_third_card)
            else:
                banker_third_card = self.remaining_deck.pop(0)
                
            banker_hand.append(banker_third_card)
            banker_score = self.calculate_baccarat_score(banker_hand)
        
        return banker_hand, player_hand, banker_score, player_score

    def calculate_remaining_probabilities(self):
        total_cards = len(self.remaining_deck)
        total_initial_cards = self.decks * 52
        
        if total_cards < 20:
            self.remaining_deck = self.initialize_deck(self.decks)
            self.current_probs = self.base_probabilities.copy()
            return
        
        card_counts = {}
        for card in card_names:
            count = self.remaining_deck.count(card)
            card_counts[card] = count
        
        point_ratios = {}
        for point in range(0, 10):
            if point == 0:
                cards_for_point = ['10', 'J', 'Q', 'K']
            else:
                cards_for_point = [card for card in card_names if card_values[card] == point]
            
            total_count = sum(card_counts[card] for card in cards_for_point)
            point_ratios[point] = total_count / total_cards
        
        high_card_ratio = point_ratios[0]
        low_card_ratio = sum(point_ratios[i] for i in [1, 2, 3, 4, 5])
        medium_card_ratio = sum(point_ratios[i] for i in [6, 7])
        eight_nine_ratio = sum(point_ratios[i] for i in [8, 9])
        
        banker_adjust = (eight_nine_ratio - 0.158) * 8 - (low_card_ratio - 0.385) * 4
        player_adjust = (low_card_ratio - 0.385) * 8 - (eight_nine_ratio - 0.158) * 4
        tie_adjust = (medium_card_ratio - 0.308) * 6
        
        consumption_ratio = (total_initial_cards - total_cards) / total_initial_cards
        consumption_effect = consumption_ratio * 2
        
        self.current_probs['banker'] = self.base_probabilities['banker'] + banker_adjust + consumption_effect
        self.current_probs['player'] = self.base_probabilities['player'] + player_adjust - consumption_effect
        self.current_probs['tie'] = self.base_probabilities['tie'] + tie_adjust
        
        self.current_probs['banker'] = max(40.0, min(52.0, self.current_probs['banker']))
        self.current_probs['player'] = max(40.0, min(52.0, self.current_probs['player']))
        self.current_probs['tie'] = max(5.0, min(15.0, self.current_probs['tie']))
        
        self.normalize_probabilities()

    def normalize_probabilities(self):
        total = sum(self.current_probs[bet] for bet in ['banker', 'player', 'tie'])
        if total > 0:
            scale = 100.0 / total
            for bet in ['banker', 'player', 'tie']:
                self.current_probs[bet] *= scale
                self.current_probs[bet] = round(self.current_probs[bet], 3)

    def calculate_ev(self, probability, payout):
        win_prob = probability / 100
        return (win_prob * payout) - ((1 - win_prob) * 1)

    def calculate_percentage_change(self, current_prob, base_prob):
        if base_prob == 0:
            return 0
        return ((current_prob - base_prob) / base_prob) * 100

    def calculate_acceleration(self, current_change, previous_change):
        """è¨ˆç®—è®ŠåŒ–ç‡åŠ é€Ÿï¼ˆç•¶å‰è®ŠåŒ–ç‡ - ä¸Šä¸€å±€è®ŠåŒ–ç‡ï¼‰"""
        return current_change - previous_change

    def update_trend_strength(self, bet_type, acceleration, percentage_change):
        """æ›´æ–°è¶¨å‹¢å¼·åº¦è¨ˆæ•¸å™¨ - v3.8.4é«˜æ¨è–¦ç‡å„ªåŒ–ç‰ˆæœ¬"""
        current_strength = self.trend_strength[bet_type]
        
        if acceleration > self.acceleration_threshold:  # 0.01
            strength_increment = max(0.02, min(3.0, abs(acceleration) * 0.8))  # ä¹˜æ•¸å¾0.5å¢åŠ åˆ°0.8
            
            # æ”¾å¯¬å¼·åº¦é™åˆ¶
            if current_strength > 12.0:  # å¾8.0å¢åŠ åˆ°12.0
                strength_increment *= 0.8  # å¾0.6å¢åŠ åˆ°0.8
            elif current_strength > 8.0:   # å¾5.0å¢åŠ åˆ°8.0
                strength_increment *= 0.9  # å¾0.8å¢åŠ åˆ°0.9
                
            new_strength = current_strength + strength_increment
            self.trend_strength[bet_type] = min(self.max_trend_strength, new_strength)
            self.trend_decay_counter[bet_type] = 0
            
        elif acceleration < -self.acceleration_threshold:
            strength_decrement = max(0.02, min(3.0, abs(acceleration) * 0.8))  # ä¹˜æ•¸å¾0.5å¢åŠ åˆ°0.8
            new_strength = current_strength - strength_decrement
            self.trend_strength[bet_type] = max(-self.max_trend_strength, new_strength)
            self.trend_decay_counter[bet_type] = 0
            
        else:
            self.trend_decay_counter[bet_type] += 1
            
            # é™ä½è¡°æ¸›ç‡
            decay_rate = self.base_decay_rate  # 0.02
            if abs(current_strength) > 15.0:  # å¾10.0å¢åŠ åˆ°15.0
                decay_rate = 0.10  # å¾0.12é™ä½åˆ°0.10
            elif abs(current_strength) > 10.0:  # å¾6.0å¢åŠ åˆ°10.0
                decay_rate = 0.06  # å¾0.08é™ä½åˆ°0.06
            elif abs(current_strength) > 5.0:   # å¾3.0å¢åŠ åˆ°5.0
                decay_rate = 0.04  # å¾0.05é™ä½åˆ°0.04
                
            decay_multiplier = min(2.0, 1.0 + (self.trend_decay_counter[bet_type] * 0.05))  # ä¹˜æ•¸å¾0.08é™ä½åˆ°0.05
            decay_rate *= decay_multiplier
            
            if current_strength > 0:
                self.trend_strength[bet_type] = max(0, current_strength - decay_rate)
            elif current_strength < 0:
                self.trend_strength[bet_type] = min(0, current_strength + decay_rate)
        
        # å¢åŠ ç´¯ç©è®ŠåŒ–æ•ˆæœ
        cumulative_effect = percentage_change * 0.04  # å¾0.03å¢åŠ åˆ°0.04
        self.cumulative_changes[bet_type] += cumulative_effect
        self.cumulative_changes[bet_type] = max(-self.max_cumulative_change, 
                                               min(self.max_cumulative_change, 
                                                   self.cumulative_changes[bet_type]))
        
        self.change_history[bet_type].append(percentage_change)
        if len(self.change_history[bet_type]) > 5:
            self.change_history[bet_type].pop(0)
        
        if len(self.change_history[bet_type]) >= 3:
            recent_changes = self.change_history[bet_type][-3:]
            if all(c > 0 for c in recent_changes) or all(c < 0 for c in recent_changes):
                pattern_bonus = 0.2
                if self.trend_strength[bet_type] > 0:
                    self.trend_strength[bet_type] = min(self.max_trend_strength, 
                                                       self.trend_strength[bet_type] + pattern_bonus)
                else:
                    self.trend_strength[bet_type] = max(-self.max_trend_strength, 
                                                       self.trend_strength[bet_type] - pattern_bonus)

    def get_dynamic_acceleration_threshold(self):
        """æ ¹æ“šé€£çºŒç„¡æ¨è–¦å±€æ•¸å‹•æ…‹èª¿æ•´åŠ é€Ÿé–¾é–¾å€¼ - v3.8.4é«˜æ¨è–¦ç‡å„ªåŒ–ç‰ˆæœ¬"""
        base_threshold = self.acceleration_threshold  # 0.01
        
        # å¤§å¹…æ¸›å°‘é€£çºŒç„¡æ¨è–¦çš„æ‡²ç½°
        if self.consecutive_no_recommendation >= 15:  # å¾10å¢åŠ åˆ°15
            return base_threshold * 0.8  # å¾0.5å¢åŠ åˆ°0.8
        elif self.consecutive_no_recommendation >= 10:  # å¾6å¢åŠ åˆ°10
            return base_threshold * 0.9  # å¾0.7å¢åŠ åˆ°0.9
        elif self.consecutive_no_recommendation >= 5:   # å¾3å¢åŠ åˆ°5
            return base_threshold * 0.95  # å¾0.85å¢åŠ åˆ°0.95
        else:
            return base_threshold

    def get_bet_recommendation(self, bet_type, percentage_change, acceleration):
        """æ ¹æ“šæ¦‚ç‡è®ŠåŒ–ç™¾åˆ†æ¯”å’ŒåŠ é€Ÿç²å–ä¸‹æ³¨æ¨è–¦ï¼ˆv3.8.4é«˜æ¨è–¦ç‡å„ªåŒ–ç‰ˆæœ¬ï¼‰"""
        if bet_type not in thresholds_dict:
            return 0, bet_type, False
        
        if bet_type == 'tie':
            return 0, bet_type, False
        
        current_accel_threshold = self.get_dynamic_acceleration_threshold()
        
        # å¤§å¹…é™ä½è¶¨å‹¢éæ¿¾é–¾é–¾å€¼
        if self.trend_filter_enabled and abs(self.trend_strength[bet_type]) < self.min_trend_strength:
            return 0, bet_type, False
        
        current_prob = self.current_probs[bet_type]
        final_bet_type = bet_type
        cumulative_bonus = 0
        is_reverse = False
        
        # å¤§å¹…æ”¾å¯¬ç´¯ç©è®ŠåŒ–çå‹µé–€æª»
        if abs(self.cumulative_changes[bet_type]) > 0.3:  # å¾0.5é™ä½åˆ°0.3
            cumulative_bonus = min(3, int(abs(self.cumulative_changes[bet_type]) * 3))  # çå‹µåŠ å€
        
        # é¦–å…ˆæª¢æŸ¥ç²¾æº–åå‘é‚è¼¯
        reverse_bet, reverse_level = improved_reverse_evaluation_full(
            bet_type, current_prob, percentage_change, acceleration, 
            {
                'trend_strength': self.trend_strength,
                'cumulative_changes': self.cumulative_changes,
                'change_history': self.change_history
            }, 
            reverse_thresholds_dict[bet_type].get("reverse_1", {})
        )
        
        if reverse_bet and reverse_level > 0:
            final_bet_type = reverse_bet
            base_level = reverse_level
            is_reverse = True
        else:
            # åŸæœ‰é–¾é–¾å€¼åˆ¤æ–·é‚è¼¯
            for level in ['7', '6', '5', '4', '3', '2', '1', '0']:  # æ–°å¢'0'ç´šåˆ¥
                if level in thresholds_dict[bet_type]:
                    threshold = thresholds_dict[bet_type][level]
                    
                    if current_prob < threshold.get("min_prob", 0):
                        continue
                    
                    if (threshold["min_change"] <= abs(percentage_change) < threshold["max_change"] and 
                        acceleration >= threshold["min_accel"]):
                        
                        base_level = threshold["level"]
                        
                        if threshold.get("reverse", False) or threshold.get("win_rate", 50) < 49:
                            final_bet_type = 'player' if bet_type == 'banker' else 'banker'
                            base_level = 1
                            is_reverse = True
                        
                        if not threshold.get("reverse", False) and threshold.get("win_rate", 50) >= 49:
                            final_level = min(20, base_level + cumulative_bonus)
                        else:
                            final_level = base_level
                        
                        return final_level, final_bet_type, is_reverse
        
        # åå‘é‚è¼¯çš„ç­‰ç´šè¨ˆç®—
        if is_reverse:
            trend_state = {
                'trend_strength': self.trend_strength,
                'cumulative_changes': self.cumulative_changes
            }
            reverse_level_adjusted = get_reverse_bet_level(
                bet_type, current_prob, percentage_change, acceleration, trend_state
            )
            final_level = max(1, min(5, base_level + reverse_level_adjusted))
            
            return final_level, final_bet_type, is_reverse
        
        return 0, bet_type, False

def get_recommendation_text(self, bet_type):
    if bet_type not in self.current_probs:
        return None
        
    current_prob = self.current_probs[bet_type]
    base_prob = self.base_probabilities[bet_type]
    payout = self.payouts[bet_type]
    ev = self.calculate_ev(current_prob, payout)
    
    percentage_change = self.calculate_percentage_change(current_prob, base_prob)
    
    acceleration = self.calculate_acceleration(percentage_change, self.previous_changes[bet_type])
    
    self.update_trend_strength(bet_type, acceleration, percentage_change)
    
    bet_level, final_bet_type, is_reverse = self.get_bet_recommendation(bet_type, percentage_change, acceleration)
    
    if bet_type == 'tie' and not self.observe_tie:
        return None
    
    chinese_names = {'banker': 'èŠ', 'player': 'é–’', 'tie': 'å’Œ'}
    
    # ç­‰ç´šåœ–æ¨™ï¼ˆåŒ…å«åå‘æ¨™è¨˜ï¼‰
    level_icons = {
        20: 'ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ ä¸‹20æ³¨',
        19: 'ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ ä¸‹19æ³¨',
        18: 'ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ ä¸‹18æ³¨',
        17: 'ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ ä¸‹17æ³¨',
        16: 'ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ ä¸‹16æ³¨',
        15: 'ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ ä¸‹15æ³¨',
        14: 'ğŸ”¥ğŸ”¥ğŸ”¥ ä¸‹14æ³¨',
        13: 'ğŸ”¥ğŸ”¥ğŸ”¥ ä¸‹13æ³¨',
        12: 'ğŸ”¥ğŸ”¥ğŸ”¥ ä¸‹12æ³¨',
        11: 'ğŸ”¥ğŸ”¥ ä¸‹11æ³¨',
        10: 'ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ ä¸‹10æ³¨',
        9: 'ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ ä¸‹9æ³¨',
        8: 'ğŸ”¥ğŸ”¥ğŸ”¥ ä¸‹8æ³¨',
        7: 'ğŸ”¥ğŸ”¥ ä¸‹7æ³¨',
        6: 'ğŸ”¥ ä¸‹6æ³¨',
        5: 'ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ ä¸‹5æ³¨',
        4: 'ğŸ”¥ğŸ”¥ğŸ”¥ ä¸‹4æ³¨', 
        3: 'ğŸ”¥ğŸ”¥ ä¸‹3æ³¨',
        2: 'ğŸ”¥ ä¸‹2æ³¨',
        1: 'âš¡âš¡ ä¸‹1æ³¨',
        0: 'âšªâšª ä¸ä¸‹æ³¨'
    }
    
    # ç¢ºä¿ bet_level åœ¨ level_icons ä¸­æœ‰å°æ‡‰çš„éµ
    if bet_level not in level_icons:
        available_levels = sorted(level_icons.keys(), reverse=True)
        for level in available_levels:
            if bet_level >= level:
                bet_level = level
                break
        else:
            bet_level = 0

    trend_icon = "â†‘" if acceleration > 0 else "â†“" if acceleration < 0 else "â†’"
    trend_strength = f"{abs(self.trend_strength[bet_type]):.1f}"
    cumulative_change = f"{self.cumulative_changes[bet_type]:.2f}"
    decay_counter = self.trend_decay_counter[bet_type]

    win_rate_info = ""
    for level in ['7', '6', '5', '4', '3', '2', '1', '0']:
        if level in self.thresholds_dict[bet_type]:
            threshold = self.thresholds_dict[bet_type][level]
            if (threshold["min_change"] <= abs(percentage_change) < threshold["max_change"] and 
                acceleration >= threshold["min_accel"] and
                current_prob >= threshold.get("min_prob", 0)):
                win_rate_info = f" | å‹ç‡: {threshold.get('win_rate', 50):.1f}%"
                break

    reverse_indicator = "ğŸ”„ğŸ”„ " if is_reverse else ""

    recommendation_text = (
        f"{reverse_indicator}{chinese_names[final_bet_type]}:\n"
        f"  æ¦‚ç‡: {current_prob:.3f} (åŸº{base_prob:.3f})\n"
        f"  è®ŠåŒ–: {percentage_change:+.2f}% | åŠ é€Ÿ: {acceleration:+.2f}% {trend_icon}{win_rate_info}\n"
        f"  è¶¨å‹¢å¼·åº¦: {trend_strength} | ç´¯ç©: {cumulative_change}% | è¡°æ¸›è¨ˆæ•¸: {decay_counter}\n"
        f"  EV: {ev:+.3f} | æ¨è–¦: {level_icons[bet_level]}\n"
        f"{'='*30}\n"
    )

    return {
        'text': recommendation_text,
        'level': bet_level,
        'ev': ev,
        'change': percentage_change,
        'acceleration': acceleration,
        'bet_type': final_bet_type,
        'current_prob': current_prob,
        'base_prob': base_prob,
        'trend_strength': self.trend_strength[bet_type],
        'cumulative_change': self.cumulative_changes[bet_type],
        'decay_counter': decay_counter,
        'is_reverse': is_reverse
    }
    # â–²â–²â–² ä½ çš„ç¨‹å¼ç¢¼çµæŸ â–²â–²â–²

def get_top_recommendation(self):
        recommendations = []
        
        for bet_type in ['banker', 'player']:
            recommendation = self.get_recommendation_text(bet_type)
            if recommendation and recommendation['level'] > 0:
                recommendations.append(recommendation)
        
        if recommendations:
            recommendations.sort(key=lambda x: (x['level'], abs(x['trend_strength'])), reverse=True)
            return recommendations[0]['bet_type'], recommendations[0]['level'], recommendations
        else:
            self.consecutive_no_recommendation += 1
            
            all_recommendations = []
            for bet_type in ['banker', 'player']:
                rec = self.get_recommendation_text(bet_type)
                if rec:
                    all_recommendations.append(rec)
            return None, 0, all_recommendations

def take_recommendation_snapshot(self):
        snapshot = {
            'banker': self.get_recommendation_text('banker'),
            'player': self.get_recommendation_text('player'),
            'timestamp': self.game_count
        }
        return snapshot

def update_probabilities_display_only(self):
        if len(self.current_cards) > 0:
            self.calculate_remaining_probabilities()
        
        for key, label in self.prob_labels.items():
            label.config(text=f"{self.current_probs[key]:.3f}")
        
        gpu_status = " | GPUåŠ é€Ÿ: å¯ç”¨" if self.gpu_enabled else " | GPUåŠ é€Ÿ: ä¸å¯ç”¨"
        self.status_label.config(text=f"å±€æ•¸ï¼š#{self.game_count} | Aç‰Œï¼š{self.a_count} | å‰©é¤˜ç‰Œï¼š{len(self.remaining_deck)} | æ¨è–¦ç¯„åœï¼š{self.THRESHOLD_min_games}-{self.THRESHOLD_max_games}å±€{gpu_status}")
        
        if self.game_count < self.THRESHOLD_min_games:
            status_text = f"ç­‰å¾…æ¨è–¦ç¯„åœï¼ˆ{self.THRESHOLD_min_games}å±€é–‹å§‹ï¼‰"
            color = '#ff6666'
        elif self.game_count <= self.THRESHOLD_max_games:
            status_text = "æ¨è–¦ç¯„åœå…§ï¼Œåˆ†æä¸­..."
            color = '#ffcc00'
        else:
            status_text = "å·²è¶…å‡ºæ¨è–¦ç¯„åœ"
            color = '#00cc66'
            
        if self.trend_filter_enabled:
            status_text += f" | è¶¨å‹¢éæ¿¾(å¼·åº¦â‰¥{self.min_trend_strength})"
            color = '#00ff00'
            
        self.data_status_label.config(text=status_text, fg=color)
        
        self.update_recommendation_display()

    # UIè¨­ç½® - å®Œå…¨æ¢å¾©v3.8.4ä½ˆå±€ + V2.1.1é«˜æ¨è–¦ç‡å„ªåŒ–
def setup_ui(self):
        title_frame = tk.Frame(self.root, bg='#2d2d2d', height=50)
        title_frame.pack(fill=tk.X, padx=10, pady=3)
        title_frame.pack_propagate(False)
        
        title_text = "ç™¾å®¶æ¨‚ AI ç®—ç‰Œé æ¸¬ v3.8.4 - GPU-DP-V2.1.1ï¼ˆé«˜æ¨è–¦ç‡å„ªåŒ–ç‰ˆï¼‰"
        if self.gpu_enabled:
            title_text += " - GPUåŠ é€Ÿå·²å•Ÿç”¨"
        else:
            title_text += " - GPUåŠ é€Ÿä¸å¯ç”¨"
            
        tk.Label(title_frame, text=title_text, 
                font=('Microsoft YaHei', 14, 'bold'), fg='white', bg='#2d2d2d').pack(expand=True)
        
        status_frame = tk.Frame(self.root, bg='#333333', height=35)
        status_frame.pack(fill=tk.X, padx=10, pady=2)
        status_frame.pack_propagate(False)
        
        gpu_status = " | GPUåŠ é€Ÿ: å¯ç”¨" if self.gpu_enabled else " | GPUåŠ é€Ÿ: ä¸å¯ç”¨"
        self.status_label = tk.Label(status_frame, 
                                    text=f"å±€æ•¸ï¼š#{self.game_count} | Aç‰Œï¼š{self.a_count} | å‰©é¤˜ç‰Œï¼š{len(self.remaining_deck)} | æ¨è–¦ç¯„åœï¼š{self.THRESHOLD_min_games}-{self.THRESHOLD_max_games}å±€{gpu_status}",
                                    font=('Microsoft YaHei', 10), fg='#ffcc00', bg='#333333')
        self.status_label.pack(side=tk.LEFT, padx=10)
        
        self.data_status_label = tk.Label(status_frame, text=f"v3.8.4é«˜æ¨è–¦ç‡ç³»çµ± - æœ€å°å¼·åº¦:{self.min_trend_strength}",
                                         font=('Microsoft YaHei', 10), fg='#00ff00', bg='#333333')
        self.data_status_label.pack(side=tk.RIGHT, padx=10)
        
        main_frame = tk.Frame(self.root, bg='#1a1a1a')
        main_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=3)
        
        left_frame = tk.Frame(main_frame, bg='#2d2d2d', width=400)
        left_frame.pack(side=tk.LEFT, fill=tk.Y, padx=(0, 5))
        left_frame.pack_propagate(False)
        
        right_frame = tk.Frame(main_frame, bg='#1a1a1a')
        right_frame.pack(side=tk.RIGHT, fill=tk.BOTH, expand=True, padx=(5, 0))
        
        self.setup_recommendation_panel(left_frame)
        self.setup_table_panel(right_frame)
        
def setup_recommendation_panel(self, parent):
        param_frame = tk.LabelFrame(parent, text="åƒæ•¸è¨­å®š v3.8.4-HR", font=('Microsoft YaHei', 10, 'bold'),
                                  fg='white', bg='#2d2d2d', bd=1, height=180)
        param_frame.pack(fill=tk.X, padx=5, pady=3)
        param_frame.pack_propagate(False)
        
        # GPUæ§åˆ¶
        gpu_frame = tk.Frame(param_frame, bg='#2d2d2d')
        gpu_frame.pack(fill=tk.X, padx=5, pady=2)
        
        if self.gpu_enabled:
            gpu_color = '#00ff00'
            gpu_text = "GPUåŠ é€Ÿ: å¯ç”¨ (v3.8.4é«˜æ¨è–¦ç‡ç³»çµ±)"
        else:
            gpu_color = '#ff6666'
            gpu_text = "GPUåŠ é€Ÿ: ä¸å¯ç”¨"
            
        tk.Label(gpu_frame, text=gpu_text, font=('Microsoft YaHei', 9, 'bold'),
                fg=gpu_color, bg='#2d2d2d').pack(side=tk.LEFT)
        
        # é«˜æ¨è–¦ç‡æ¨¡å¼æŒ‰éˆ•
        hr_btn_frame = tk.Frame(gpu_frame, bg='#2d2d2d')
        hr_btn_frame.pack(side=tk.RIGHT, padx=5)
        
        tk.Button(hr_btn_frame, text="å•Ÿç”¨é«˜æ¨è–¦ç‡", font=('Microsoft YaHei', 8),
                 command=self.enable_high_recommendation_mode, bg='#9b59b6', fg='white', width=10).pack(side=tk.LEFT, padx=2)
        
        # è¶¨å‹¢éæ¿¾æ§åˆ¶
        trend_frame = tk.Frame(param_frame, bg='#2d2d2d')
        trend_frame.pack(fill=tk.X, padx=5, pady=2)
        
        self.trend_filter_var = tk.BooleanVar(value=self.trend_filter_enabled)
        trend_check = tk.Checkbutton(trend_frame, text="è¶¨å‹¢éæ¿¾", variable=self.trend_filter_var,
                                   command=self.toggle_trend_filter, font=('Microsoft YaHei', 9),
                                   fg='white', bg='#2d2d2d', selectcolor='#1a1a1a')
        trend_check.pack(side=tk.LEFT)
        
        tk.Label(trend_frame, text="æœ€å°è¶¨å‹¢å¼·åº¦:", font=('Microsoft YaHei', 8), 
                fg='white', bg='#2d2d2d').pack(side=tk.LEFT, padx=(10,2))
        
        self.min_trend_var = tk.StringVar(value="0.0001")  # è¨­ç½®ç‚ºé«˜æ¨è–¦ç‡åƒæ•¸
        trend_spinbox = tk.Spinbox(trend_frame, from_=0.0001, to=0.5, increment=0.0001, width=8,
                                 textvariable=self.min_trend_var, command=self.update_trend_settings,
                                 font=('Microsoft YaHei', 8))
        trend_spinbox.pack(side=tk.LEFT, padx=2)
        
        range_frame = tk.Frame(param_frame, bg='#2d2d2d')
        range_frame.pack(fill=tk.X, padx=5, pady=2)
        
        tk.Label(range_frame, text="æ¨è–¦ç¯„åœ:", font=('Microsoft YaHei', 9), 
                fg='white', bg='#2d2d2d').pack(side=tk.LEFT)
        
        self.min_games_var = tk.StringVar(value=str(self.THRESHOLD_min_games))
        min_spinbox = tk.Spinbox(range_frame, from_=1, to=100, width=4,
                               textvariable=self.min_games_var, command=self.update_thresholds,
                               font=('Microsoft YaHei', 8))
        min_spinbox.pack(side=tk.LEFT, padx=2)
        
        tk.Label(range_frame, text="å±€~", font=('Microsoft YaHei', 8), 
                fg='white', bg='#2d2d2d').pack(side=tk.LEFT)
        
        self.max_games_var = tk.StringVar(value=str(self.THRESHOLD_max_games))
        max_spinbox = tk.Spinbox(range_frame, from_=10, to=200, width=4,
                               textvariable=self.max_games_var, command=self.update_thresholds,
                               font=('Microsoft YaHei', 8))
        max_spinbox.pack(side=tk.LEFT, padx=2)
        
        tk.Label(range_frame, text="å±€", font=('Microsoft YaHei', 8), 
                fg='white', bg='#2d2d2d').pack(side=tk.LEFT)
        
        auto_frame = tk.Frame(param_frame, bg='#2d2d2d')
        auto_frame.pack(fill=tk.X, padx=5, pady=2)
        
        tk.Label(auto_frame, text="è‡ªå‹•æ¨¡æ“¬:", font=('Microsoft YaHei', 9), 
                fg='white', bg='#2d2d2d').pack(side=tk.LEFT)
        
        self.auto_games_var = tk.StringVar(value="10000")
        auto_spinbox = tk.Spinbox(auto_frame, from_=1, to=100000, width=8,
                                textvariable=self.auto_games_var,
                                font=('Microsoft YaHei', 8))
        auto_spinbox.pack(side=tk.LEFT, padx=2)
        
        tk.Label(auto_frame, text="å±€", font=('Microsoft YaHei', 8), 
                fg='white', bg='#2d2d2d').pack(side=tk.LEFT)
        
        sim_btn_frame = tk.Frame(auto_frame, bg='#2d2d2d')
        sim_btn_frame.pack(side=tk.RIGHT, padx=5)
        
        tk.Button(sim_btn_frame, text="GPUæ¨¡æ“¬", font=('Microsoft YaHei', 8),
                 command=lambda: self.start_gpu_simulation(int(self.auto_games_var.get())), 
                 bg='#9b59b6', fg='white', width=8).pack(side=tk.LEFT, padx=2)
        
        tk.Button(sim_btn_frame, text="CPUæ¨¡æ“¬", font=('Microsoft YaHei', 8),
                 command=self.start_auto_simulate, bg='#e74c3c', width=8).pack(side=tk.LEFT, padx=2)
        
        tk.Button(sim_btn_frame, text="åœæ­¢", font=('Microsoft YaHei', 8),
                 command=self.stop_auto_simulate, bg='#95a5a6', width=6).pack(side=tk.LEFT, padx=2)
        
        strategy_frame = tk.LabelFrame(parent, text="ç­–ç•¥è¨­å®š", font=('Microsoft YaHei', 10, 'bold'),
                                      fg='white', bg='#2d2d2d', bd=1, height=60)
        strategy_frame.pack(fill=tk.X, padx=5, pady=3)
        strategy_frame.pack_propagate(False)
        
        btn_frame = tk.Frame(strategy_frame, bg='#2d2d2d')
        btn_frame.pack(fill=tk.X, padx=3, pady=2)
        
        tk.Button(btn_frame, text="èŠé–’å°ˆç”¨", font=('Microsoft YaHei', 8),
                 command=lambda: self.set_strategy('bp'), bg='#3498db', width=8).pack(side=tk.LEFT, padx=1)
        
        strategy_text = f"ç•¶å‰: èŠé–’å°ˆç”¨ç­–ç•¥ | v3.8.4é«˜æ¨è–¦ç‡ç³»çµ±"
        if self.gpu_enabled:
            strategy_text += " | GPUåŠ é€Ÿ"
            
        self.strategy_label = tk.Label(strategy_frame, text=strategy_text, 
                                      font=('Microsoft YaHei', 9), fg='#ffcc00', bg='#2d2d2d')
        self.strategy_label.pack(pady=1)
        
        ai_frame = tk.LabelFrame(parent, text="AIæ¨è–¦ä¸‹æ³¨", font=('Microsoft YaHei', 12, 'bold'),
                                fg='white', bg='#2d2d2d', bd=2)
        ai_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=3)
        
        self.recommendation_text = tk.Text(ai_frame, height=12, font=('Microsoft YaHei', 9),
                                          fg='white', bg='#1a1a1a', wrap=tk.WORD)
        scrollbar = tk.Scrollbar(ai_frame, command=self.recommendation_text.yview)
        self.recommendation_text.config(yscrollcommand=scrollbar.set)
        self.recommendation_text.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        self.result_label = tk.Label(ai_frame, text="", font=('Microsoft YaHei', 14, 'bold'),
                                    fg='#ffcc00', bg='#2d2d2d')
        self.result_label.pack(fill=tk.X, side=tk.BOTTOM, pady=5)
        
        self.update_recommendation_display()
        
def setup_table_panel(self, parent):
        prob_frame = tk.Frame(parent, bg='#2d2d2d', height=150)
        prob_frame.pack(fill=tk.X, pady=3)
        prob_frame.pack_propagate(False)
        
        self.setup_probability_display(prob_frame)
        
        card_frame = tk.Frame(parent, bg='#1a1a1a')
        card_frame.pack(fill=tk.BOTH, expand=True)
        
        self.setup_card_buttons(card_frame)
        
        bottom_frame = tk.Frame(parent, bg='#2d2d2d', height=60)
        bottom_frame.pack(fill=tk.X, pady=3)
        bottom_frame.pack_propagate(False)
        
        self.setup_bottom_controls(bottom_frame)
        
def setup_probability_display(self, parent):
        prob_grid = tk.Frame(parent, bg='#2d2d2d')
        prob_grid.pack(expand=True, fill=tk.BOTH, padx=5, pady=5)
        
        prob_items = [
            ('é–’', 'player', '#ff6b6b'),
            ('èŠ', 'banker', '#4ecdc4'), 
            ('å’Œ', 'tie', '#45b7d1')
        ]
        
        self.prob_labels = {}
        
        for i, (name, key, color) in enumerate(prob_items):
            frame = tk.Frame(prob_grid, bg='#2d2d2d')
            frame.grid(row=0, column=i, sticky='ew', pady=1, padx=5)
            
            prob_frame = tk.Frame(frame, bg='#3d3d3d', relief=tk.RAISED, bd=1, width=100, height=80)
            prob_frame.pack(side=tk.LEFT, expand=True, fill=tk.BOTH, padx=1)
            prob_frame.pack_propagate(False)
            
            title_label = tk.Label(prob_frame, text=name, font=('Microsoft YaHei', 9, 'bold'),
                                  fg='white', bg=color, height=1)
            title_label.pack(fill=tk.X)
            
            prob_label = tk.Label(prob_frame, text=f"{self.current_probs[key]:.3f}", 
                                 font=('Microsoft YaHei', 10, 'bold'), fg='white', bg='#3d3d3d')
            prob_label.pack(expand=True)
            
            self.prob_labels[key] = prob_label
            
def setup_card_buttons(self, parent):
        self.current_cards_label = tk.Label(parent, text="ç•¶å‰ç‰Œå±€ï¼šç­‰å¾…è¼¸å…¥...", 
                                           font=('Microsoft YaHei', 12), fg='white', bg='#1a1a1a')
        self.current_cards_label.pack(pady=5)
        
        row1_frame = tk.Frame(parent, bg='#1a1a1a')
        row1_frame.pack(fill=tk.X, pady=2)
        
        cards_row1 = ['A', '2', '3', '4', '5']
        for card in cards_row1:
            btn = tk.Button(row1_frame, text=card, font=('Arial', 20, 'bold'),
                           width=6, height=2, bg='#e74c3c', fg='white',
                           command=lambda c=card: self.card_clicked(c))
            btn.pack(side=tk.LEFT, padx=2)
        
        row2_frame = tk.Frame(parent, bg='#1a1a1a')
        row2_frame.pack(fill=tk.X, pady=2)
        
        cards_row2 = ['6', '7', '8', '9', '10']
        for card in cards_row2:
            btn = tk.Button(row2_frame, text=card, font=('Arial', 20, 'bold'),
                           width=6, height=2, bg='#3498db', fg='white',
                           command=lambda c=card: self.card_clicked(c))
            btn.pack(side=tk.LEFT, padx=2)
        
        row3_frame = tk.Frame(parent, bg='#1a1a1a')
        row3_frame.pack(fill=tk.X, pady=2)
        
        cards_row3 = ['J', 'Q', 'K']
        for card in cards_row3:
            btn = tk.Button(row3_frame, text=card, font=('Arial', 20, 'bold'),
                           width=6, height=2, bg='#9b59b6', fg='white',
                           command=lambda c=card: self.card_clicked(c))
            btn.pack(side=tk.LEFT, padx=2)
            
def setup_bottom_controls(self, parent):
        control_frame = tk.Frame(parent, bg='#2d2d2d')
        control_frame.pack(expand=True)
        
        tk.Button(control_frame, text="å®Œæˆæœ¬å±€", font=('Microsoft YaHei', 10),
                 bg='#27ae60', fg='white', width=10, height=1,
                 command=self.complete_round).pack(side=tk.LEFT, padx=5)
        
        tk.Button(control_frame, text="é‡æ–°è¼¸å…¥", font=('Microsoft YaHei', 10),
                 bg='#e67e22', fg='white', width=10, height=1,
                 command=self.reset_input).pack(side=tk.LEFT, padx=5)
        
        tk.Button(control_frame, text="æ­·å²åˆ†æ", font=('Microsoft YaHei', 10),
                 bg='#3498db', fg='white', width=10, height=1,
                 command=self.show_history).pack(side=tk.LEFT, padx=5)
        
        tk.Button(control_frame, text="å–®å±€æ¨¡æ“¬", font=('Microsoft YaHei', 10),
                 bg='#9b59b6', fg='white', width=10, height=1,
                 command=self.auto_simulate).pack(side=tk.LEFT, padx=5)
        
        tk.Button(control_frame, text="é‡ç½®ç³»çµ±", font=('Microsoft YaHei', 10),
                 bg='#e74c3c', fg='white', width=10, height=1,
                 command=self.reset_system).pack(side=tk.LEFT, padx=5)
        
        tk.Button(control_frame, text="å°å‡ºCSV", font=('Microsoft YaHei', 10),
                 bg='#f39c12', fg='white', width=10, height=1,
                 command=self.export_to_csv).pack(side=tk.LEFT, padx=5)
        
        path_frame = tk.Frame(parent, bg='#2d2d2d', height=25)
        path_frame.pack(fill=tk.X, pady=2)
        path_frame.pack_propagate(False)
        
        self.path_label = tk.Label(path_frame, text=f"å°å‡ºè·¯å¾‘: {self.export_path}", 
                                  font=('Microsoft YaHei', 8), fg='#cccccc', bg='#2d2d2d')
        self.path_label.pack(side=tk.LEFT, padx=10)
        
        tk.Button(path_frame, text="æ›´æ”¹è·¯å¾‘", font=('Microsoft YaHei', 8),
                 command=self.change_export_path, bg='#34495e', fg='white', width=8).pack(side=tk.RIGHT, padx=10)
        
def change_export_path(self):
        new_path = filedialog.askdirectory(title="é¸æ“‡CSVå°å‡ºç›®éŒ„")
        if new_path:
            self.export_path = new_path
            self.path_label.config(text=f"å°å‡ºè·¯å¾‘: {self.export_path}")
            messagebox.showinfo("æˆåŠŸ", f"å°å‡ºè·¯å¾‘å·²æ›´æ”¹ç‚º: {self.export_path}")
            
def card_clicked(self, card):
        if len(self.current_cards) >= 6:
            messagebox.showwarning("è­¦å‘Š", "ä¸€å±€æœ€å¤š6å¼µç‰Œï¼")
            return
            
        self.current_cards.append(card)
        
        if card in self.remaining_deck:
            self.remaining_deck.remove(card)
        
        if card == 'A':
            self.a_count += 1
            
        cards_text = f"ç•¶å‰ç‰Œå±€ï¼š{' '.join(self.current_cards)}"
        self.current_cards_label.config(text=cards_text)
        
        self.update_probabilities_display_only()
        
def complete_round(self):
        if len(self.current_cards) < 4:
            messagebox.showwarning("è­¦å‘Š", "è‡³å°‘éœ€è¦4å¼µç‰Œæ‰èƒ½å®Œæˆä¸€å±€ï¼")
            return
        
        current_changes = {}
        for bet_type in ['banker', 'player', 'tie']:
            current_prob = self.current_probs[bet_type]
            base_prob = self.base_probabilities[bet_type]
            current_changes[bet_type] = self.calculate_percentage_change(current_prob, base_prob)
        
        recommendation_snapshot = self.take_recommendation_snapshot()
        
        banker_hand, player_hand, banker_score, player_score = self.simulate_baccarat_round(self.current_cards)
        
        if banker_score > player_score:
            winner = 'èŠ'
            winner_en = 'banker'
        elif player_score > banker_score:
            winner = 'é–’'
            winner_en = 'player'
        else:
            winner = 'å’Œ'
            winner_en = 'tie'
        
        top_recommendation, bet_level, all_recommendations = self.get_top_recommendation()
        recommendation_result = ""
        trend_icon = "â†‘" if acceleration > 0 else "â†“" if acceleration < 0 else "â†’"
        trend_strength = f"{abs(self.trend_strength[bet_type]):.1f}"
        cumulative_change = f"{self.cumulative_changes[bet_type]:.2f}"
        decay_counter = self.trend_decay_counter[bet_type]
        
        win_rate_info = ""
        for level in ['7', '6', '5', '4', '3', '2', '1', '0']:
            if level in thresholds_dict[bet_type]:
                threshold = thresholds_dict[bet_type][level]
                if (threshold["min_change"] <= abs(percentage_change) < threshold["max_change"] and 
                    acceleration >= threshold["min_accel"] and
                    current_prob >= threshold.get("min_prob", 0)):
                    win_rate_info = f" | å‹ç‡: {threshold.get('win_rate', 50):.1f}%"
                    break
        
        reverse_indicator = "ğŸ”„ğŸ”„ " if is_reverse else ""
        
        recommendation_text = (
            f"{reverse_indicator}{chinese_names[final_bet_type]}:\n"
            f"  æ¦‚ç‡: {current_prob:.3f} (åŸº{base_prob:.3f})\n"
            f"  è®ŠåŒ–: {percentage_change:+.2f}% | åŠ é€Ÿ: {acceleration:+.2f}% {trend_icon}{win_rate_info}\n"
            f"  è¶¨å‹¢å¼·åº¦: {trend_strength} | ç´¯ç©: {cumulative_change}% | è¡°æ¸›è¨ˆæ•¸: {decay_counter}\n"
            f"  EV: {ev:+.3f} | æ¨è–¦: {level_icons[bet_level]}\n"
            f"{'='*30}\n"
        )
        
        return {
            'text': recommendation_text,
            'level': bet_level,
            'ev': ev,
            'change': percentage_change,
            'acceleration': acceleration,
            'bet_type': final_bet_type,
            'current_prob': current_prob,
            'base_prob': base_prob,
            'trend_strength': self.trend_strength[bet_type],
            'cumulative_change': self.cumulative_changes[bet_type],
            'decay_counter': decay_counter,
            'is_reverse': is_reverse
        }

def get_top_recommendation(self):
        recommendations = []
        
        for bet_type in ['banker', 'player']:
            recommendation = self.get_recommendation_text(bet_type)
            if recommendation and recommendation['level'] > 0:
                recommendations.append(recommendation)
        
        if recommendations:
            recommendations.sort(key=lambda x: (x['level'], abs(x['trend_strength'])), reverse=True)
            return recommendations[0]['bet_type'], recommendations[0]['level'], recommendations
        else:
            self.consecutive_no_recommendation += 1
            
            all_recommendations = []
            for bet_type in ['banker', 'player']:
                rec = self.get_recommendation_text(bet_type)
                if rec:
                    all_recommendations.append(rec)
            return None, 0, all_recommendations

def take_recommendation_snapshot(self):
        snapshot = {
            'banker': self.get_recommendation_text('banker'),
            'player': self.get_recommendation_text('player'),
            'timestamp': self.game_count
        }
        return snapshot

def update_probabilities_display_only(self):
        if len(self.current_cards) > 0:
            self.calculate_remaining_probabilities()
        
        for key, label in self.prob_labels.items():
            label.config(text=f"{self.current_probs[key]:.3f}")
        
        gpu_status = " | GPUåŠ é€Ÿ: å¯ç”¨" if self.gpu_enabled else " | GPUåŠ é€Ÿ: ä¸å¯ç”¨"
        self.status_label.config(text=f"å±€æ•¸ï¼š#{self.game_count} | Aç‰Œï¼š{self.a_count} | å‰©é¤˜ç‰Œï¼š{len(self.remaining_deck)} | æ¨è–¦ç¯„åœï¼š{self.THRESHOLD_min_games}-{self.THRESHOLD_max_games}å±€{gpu_status}")
        
        if self.game_count < self.THRESHOLD_min_games:
            status_text = f"ç­‰å¾…æ¨è–¦ç¯„åœï¼ˆ{self.THRESHOLD_min_games}å±€é–‹å§‹ï¼‰"
            color = '#ff6666'
        elif self.game_count <= self.THRESHOLD_max_games:
            status_text = "æ¨è–¦ç¯„åœå…§ï¼Œåˆ†æä¸­..."
            color = '#ffcc00'
        else:
            status_text = "å·²è¶…å‡ºæ¨è–¦ç¯„åœ"
            color = '#00cc66'
            
        if self.trend_filter_enabled:
            status_text += f" | è¶¨å‹¢éæ¿¾(å¼·åº¦â‰¥{self.min_trend_strength})"
            color = '#00ff00'
            
        self.data_status_label.config(text=status_text, fg=color)
        
        self.update_recommendation_display()

def update_recommendation_display(self, snapshot=None):
        if len(self.current_cards) > 0:
            self.calculate_remaining_probabilities()
        
        recommendations = []
        
        if snapshot:
            for bet_type in ['banker', 'player']:
                if snapshot.get(bet_type):
                    recommendations.append(snapshot[bet_type])
        else:
            for bet_type in ['banker', 'player']:
                recommendation = self.get_recommendation_text(bet_type)
                if recommendation:
                    recommendations.append(recommendation)
        
        recommendations.sort(key=lambda x: x['level'], reverse=True)
        
        self.recommendation_text.config(state=tk.NORMAL)
        self.recommendation_text.delete(1.0, tk.END)
        
        gpu_info = " | GPUåŠ é€Ÿ: å¯ç”¨" if self.gpu_enabled else " | GPUåŠ é€Ÿ: ä¸å¯ç”¨"
        range_info = f"æ¨è–¦ç¯„åœ: ç¬¬{self.THRESHOLD_min_games}~{self.THRESHOLD_max_games}å±€ | ç•¶å‰å±€æ•¸: {self.game_count}å±€{gpu_info}\n"
        range_info += f"ç•¶å‰ç­–ç•¥: èŠé–’å°ˆç”¨ | ç‰Œå‰¯æ•¸: {self.decks}å‰¯\n"
        range_info += f"è¶¨å‹¢éæ¿¾: {'å•Ÿç”¨' if self.trend_filter_enabled else 'ç¦ç”¨'} | æœ€å°å¼·åº¦: {self.min_trend_strength}\n"
        range_info += f"æœ€å¤§è¶¨å‹¢å¼·åº¦: {self.max_trend_strength} | å‹•æ…‹è¡°æ¸›: å•Ÿç”¨\n"
        range_info += f"ä¸‹æ³¨ç­–ç•¥: v3.8.4é«˜æ¨è–¦ç‡ç³»çµ±ï¼ˆæ¨è–¦ç‡45-65%ï¼‰\n"
        range_info += f"ç³»çµ±ç‰¹é»: è¶¨å‹¢åŠ é€Ÿ + ä½é–¾å€¼ + å‹•æ…‹è¡°æ¸› + ç²¾æº–åå‘\n"
        if self.gpu_simulation_history:
            range_info += f"GPUæ¨¡æ“¬æ¬¡æ•¸: {len(self.gpu_simulation_history)}æ¬¡\n"
        range_info += "="*40 + "\n\n"
        
        self.recommendation_text.insert(tk.END, range_info)
        
        if recommendations:
            for rec in recommendations:
                start_index = self.recommendation_text.index(tk.END)
                self.recommendation_text.insert(tk.END, rec['text'])
                
                if rec['level'] >= 10:
                    color = '#ff0000'
                elif rec['level'] >= 5:
                    color = '#ff4444'
                elif rec['level'] >= 3:
                    color = '#ffaa00'
                elif rec['level'] >= 1:
                    color = '#ffff00'
                else:
                    color = '#cccccc'
                    
                end_index = self.recommendation_text.index(tk.END)
                self.recommendation_text.tag_add(f"color_{rec['bet_type']}", start_index, end_index)
                self.recommendation_text.tag_config(f"color_{rec['bet_type']}", foreground=color)
        else:
            self.recommendation_text.insert(tk.END, "è«‹è¼¸å…¥ç‰Œå±€æ•¸æ“š...\n\n")
            self.recommendation_text.insert(tk.END, f"ç•¶å‰æ¦‚ç‡: èŠ{self.current_probs['banker']:.3f} é–’{self.current_probs['player']:.3f} å’Œ{self.current_probs['tie']:.3f}")
        
        if self.current_result:
            self.recommendation_text.insert(tk.END, f"\n\n{self.current_result}")
        
        self.recommendation_text.config(state=tk.DISABLED)
        
        self.result_label.config(text=self.current_result)
    
def set_strategy(self, strategy_type):
        self.observe_bp = True
        self.observe_tie = False
        strategy_text = f"ç•¶å‰: èŠé–’å°ˆç”¨ç­–ç•¥ | v3.8.4é«˜æ¨è–¦ç‡ç³»çµ±"
        if self.gpu_enabled:
            strategy_text += " | GPUåŠ é€Ÿ"
        self.strategy_label.config(text=strategy_text)

def get_chinese_name(self, bet_type):
        chinese_names = {
            'banker': 'èŠ', 'player': 'é–’', 'tie': 'å’Œ'
        }
        return chinese_names.get(bet_type, bet_type)

def reset_input(self):
        for card in self.current_cards:
            self.remaining_deck.append(card)
        
        if self.current_cards and 'A' in self.current_cards:
            self.a_count -= self.current_cards.count('A')
            
        self.current_cards = []
        self.current_cards_label.config(text="ç•¶å‰ç‰Œå±€ï¼šç­‰å¾…è¼¸å…¥...")
        self.update_probabilities_display_only()

def reset_system(self):
        result = messagebox.askyesno("ç¢ºèª", "ç¢ºå®šè¦é‡ç½®æ•´å€‹ç³»çµ±å—ï¼Ÿæ‰€æœ‰æ­·å²æ•¸æ“šå°‡è¢«æ¸…é™¤ã€‚")
        if result:
            self.game_count = 1
            self.a_count = 0
            self.remaining_deck = self.initialize_deck(self.decks)
            self.history = []
            self.current_probs = self.base_probabilities.copy()
            self.current_cards = []
            self.current_result = ""
            self.manual_threshold_set = False
            self.auto_sim_results = []
            self.gpu_simulation_history = []
            self.gpu_detailed_results = []
            
            # é‡ç½®è¶¨å‹¢ç‹€æ…‹
            self.previous_changes = {'banker': 0.0, 'player': 0.0, 'tie': 0.0}
            self.trend_strength = {'banker': 0.0, 'player': 0.0, 'tie': 0.0}
            self.consecutive_no_recommendation = 0
            self.cumulative_changes = {'banker': 0.0, 'player': 0.0, 'tie': 0.0}
            self.change_history = {'banker': [], 'player': [], 'tie': []}
            self.trend_decay_counter = {'banker': 0, 'player': 0, 'tie': 0}
            
            for key in self.recommendation_stats:
                self.recommendation_stats[key] = {'bet': 0, 'win': 0, 'amount': 0}
            
            gpu_status = " | GPUåŠ é€Ÿ: å¯ç”¨" if self.gpu_enabled else " | GPUåŠ é€Ÿ: ä¸å¯ç”¨"
            self.status_label.config(text=f"å±€æ•¸ï¼š#{self.game_count} | Aç‰Œï¼š{self.a_count} | å‰©é¤˜ç‰Œï¼š{len(self.remaining_deck)} | æ¨è–¦ç¯„åœï¼š{self.THRESHOLD_min_games}-{self.THRESHOLD_max_games}å±€{gpu_status}")
            self.current_cards_label.config(text="ç•¶å‰ç‰Œå±€ï¼šç­‰å¾…è¼¸å…¥...")
            self.data_status_label.config(text=f"v3.8.4é«˜æ¨è–¦ç‡ç³»çµ± - æœ€å°å¼·åº¦:{self.min_trend_strength}", fg='#00ff00')
            self.update_recommendation_display()
            messagebox.showinfo("æç¤º", "ç³»çµ±å·²é‡ç½® - v3.8.4é«˜æ¨è–¦ç‡ç³»çµ±")

def auto_simulate(self):
        num_cards = random.randint(4, 6)
        self.current_cards = []
        
        for _ in range(num_cards):
            if self.remaining_deck:
                card = random.choice(self.remaining_deck)
                self.current_cards.append(card)
                self.remaining_deck.remove(card)
                
                if card == 'A':
                    self.a_count += 1
        
        cards_text = f"ç•¶å‰ç‰Œå±€ï¼š{' '.join(self.current_cards)}"
        self.current_cards_label.config(text=cards_text)
        self.update_probabilities_display_only()

def start_auto_simulate(self):
        if self.simulation_running:
            return
            
        try:
            num_games = int(self.auto_games_var.get())
            if num_games <= 0:
                messagebox.showerror("éŒ¯èª¤", "è«‹è¼¸å…¥æœ‰æ•ˆçš„å±€æ•¸")
                return
        except ValueError:
            messagebox.showerror("éŒ¯èª¤", "è«‹è¼¸å…¥æœ‰æ•ˆçš„æ•¸å­—")
            return
        
        self.simulation_running = True
        self.simulation_stop_flag = False
        self.auto_sim_results = []
        
        self.root.after(100, lambda: self.run_auto_simulation(num_games, 0))
    
def stop_auto_simulate(self):
        self.simulation_stop_flag = True
    
def run_auto_simulation(self, total_games, completed_games):
        if self.simulation_stop_flag or completed_games >= total_games:
            self.simulation_running = False
            self.show_simulation_results()
            return
        
        self.auto_simulate()
        self.complete_round()
        
        if self.history:
            last_round = self.history[-1]
            result = {
                'round': last_round['round'],
                'winner': last_round['winner_chinese'],
                'recommendation': last_round['recommendation_chinese'],
                'bet_level': last_round['bet_level'],
                'is_reverse': last_round.get('is_reverse', False),
                'result': "âœ“" if "âœ“" in last_round['recommendation_result'] else 
                         "âœ—âœ—" if "âœ—âœ—" in last_round['recommendation_result'] else "â–â–",
                'banker_prob': last_round['probabilities']['banker'],
                'player_prob': last_round['probabilities']['player'],
                'tie_prob': last_round['probabilities']['tie'],
                'banker_change': self.calculate_percentage_change(
                    last_round['probabilities']['banker'], self.base_probabilities['banker']),
                'player_change': self.calculate_percentage_change(
                    last_round['probabilities']['player'], self.base_probabilities['player']),
                'tie_change': self.calculate_percentage_change(
                    last_round['probabilities']['tie'], self.base_probabilities['tie'])
            }
            self.auto_sim_results.append(result)
        
        progress = f"CPUæ¨¡æ“¬é€²åº¦: {completed_games+1}/{total_games}"
        self.data_status_label.config(text=progress, fg='#ffcc00')
        
        self.root.after(100, lambda: self.run_auto_simulation(total_games, completed_games + 1))
    
def show_simulation_results(self):
        if not self.auto_sim_results:
            return
            
        total_games = len(self.auto_sim_results)
        recommended_games = sum(1 for r in self.auto_sim_results if r['bet_level'] > 0)
        win_games = sum(1 for r in self.auto_sim_results if r['result'] == 'âœ“')
        reverse_games = sum(1 for r in self.auto_sim_results if r.get('is_reverse', False))
        total_profit = sum(self.recommendation_stats[bet]['amount'] for bet in ['banker', 'player', 'tie'])
        
        result_text = f"è‡ªå‹•æ¨¡æ“¬å®Œæˆ: {total_games}å±€\n"
        result_text += f"æ¨è–¦å±€æ•¸: {recommended_games}å±€ ({recommended_games/total_games*100:.1f}%)\n"
        result_text += f"åå‘æ¨è–¦: {reverse_games}å±€ ({reverse_games/total_games*100:.1f}%)\n"
        if recommended_games > 0:
            result_text += f"æ¨è–¦å‹ç‡: {win_games}/{recommended_games} ({win_games/recommended_games*100:.1f}%)\n"
        result_text += f"ç¸½ç›ˆåˆ©: {total_profit:.2f}\n\n"
        
        result_text += "æœ€è¿‘5å±€çµæœ:\n"
        for result in self.auto_sim_results[-5:]:
            result_text += f"ç¬¬{result['round']}å±€: {result['winner']}è´, "
            if result['bet_level'] > 0:
                reverse_indicator = "ğŸ”„ğŸ”„" if result.get('is_reverse', False) else ""
                result_text += f"æ¨è–¦{reverse_indicator}{result['recommendation']}({result['bet_level']}æ³¨) {result['result']}\n"
            else:
                result_text += "ç„¡æ¨è–¦\n"
        
        messagebox.showinfo("è‡ªå‹•æ¨¡æ“¬çµæœ v3.8.4", result_text)

def start_gpu_simulation(self, num_simulations=10000):
        """å•Ÿå‹•GPUå¤§è¦æ¨¡æ¨¡æ“¬ - v3.8.4 é«˜æ¨è–¦ç‡å„ªåŒ–ç‰ˆæœ¬"""
        if not self.gpu_enabled:
            messagebox.showwarning("GPUä¸å¯ç”¨", "GPUåŠ é€Ÿä¸å¯ç”¨ï¼Œå°‡ä½¿ç”¨CPUæ¨¡æ“¬")
            return self.start_auto_simulate()
        
        if self.simulation_running:
            return
            
        self.simulation_running = True
        self.simulation_stop_flag = False
        
        self.data_status_label.config(text=f"GPUå¤§è¦æ¨¡æ¨¡æ“¬ä¸­... 0/{num_simulations}", fg='#ff00ff')
        
        def gpu_simulation_thread():
            try:
                start_time = time.time()
                
                print(f"ğŸ®ğŸ® é–‹å§‹GPUæ¨¡æ“¬: {num_simulations}å±€ - ä½¿ç”¨v3.8.4é«˜æ¨è–¦ç‡å„ªåŒ–ç³»çµ±")
                results = self.gpu_simulator.mass_simulation(num_simulations)
                
                end_time = time.time()
                simulation_time = end_time - start_time
                
                self.root.after(0, lambda: self.process_gpu_results(
                    results, num_simulations, simulation_time
                ))
                
            except Exception as e:
                print(f"âŒâŒ GPUæ¨¡æ“¬éŒ¯èª¤: {e}")
                self.root.after(0, lambda: self.fallback_to_cpu_simulation(num_simulations))
        
        thread = threading.Thread(target=gpu_simulation_thread)
        thread.daemon = True
        thread.start()

def process_gpu_results(self, results, num_simulations, simulation_time):
        """è™•ç†GPUæ¨¡æ“¬çµæœä¸¦æ•´åˆåˆ°æ­·å²æ•¸æ“š"""
        self.simulation_running = False
        
        gpu_sim_record = {
            'type': 'gpu_simulation',
            'timestamp': datetime.now(),
            'num_simulations': num_simulations,
            'simulation_time': simulation_time,
            'results': results,
            'performance': results.get('performance', {}),
            'detailed_results': results.get('detailed_results', [])
        }
        
        self.gpu_simulation_history.append(gpu_sim_record)
        self.gpu_detailed_results.extend(results.get('detailed_results', []))
        
        self.convert_gpu_to_standard_history(results, num_simulations)
        
        speed = num_simulations / simulation_time
        performance_info = f"GPUæ¨¡æ“¬å®Œæˆ: {num_simulations}å±€ | ç”¨æ™‚: {simulation_time:.2f}ç§’ | é€Ÿåº¦: {speed:.0f}å±€/ç§’"
        
        result_text = f"{performance_info}\n\n"
        result_text += f"èŠå®¶å‹: {results['banker_wins']}å±€ ({results['banker_win_rate']:.2f}%)\n"
        result_text += f"é–’å®¶å‹: {results['player_wins']}å±€ ({results['player_win_rate']:.2f}%)\n"
        result_text += f"å’Œå±€: {results['ties']}å±€ ({results['tie_rate']:.2f}%)\n\n"
        
        gpu_stats = self.calculate_gpu_recommendation_stats(results['detailed_results'])
        result_text += "=== æ¨è–¦é …ç›®çµ±è¨ˆ ===\n"
        total_bet = 0
        total_win = 0
        total_amount = 0
        reverse_count = 0
        
        for bet_type, stats in gpu_stats.items():
            if stats['bet'] > 0:
                win_rate = stats['win'] / stats['bet'] * 100 if stats['bet'] > 0 else 0
                chinese_name = self.get_chinese_name(bet_type)
                reverse_indicator = "ğŸ”„ğŸ”„" if stats.get('is_reverse', False) else ""
                result_text += f"æ¨è–¦{reverse_indicator}{chinese_name}: {stats['win']}/{stats['bet']} ({win_rate:.1f}%)ï¼Œæ·¨åˆ©: {stats['amount']:.2f}\n"
                total_bet += stats['bet']
                total_win += stats['win']
                total_amount += stats['amount']
                if stats.get('is_reverse', False):
                    reverse_count += stats['bet']
        
        if total_bet > 0:
            overall_win_rate = total_win / total_bet * 100
            reverse_rate = (reverse_count / total_bet) * 100 if total_bet > 0 else 0
            result_text += f"\nç¸½è¨ˆ: {total_win}/{total_bet} ({overall_win_rate:.1f}%)ï¼Œç¸½æ·¨åˆ©: {total_amount:.2f}\n"
            result_text += f"åå‘æ¨è–¦: {reverse_count}å±€ ({reverse_rate:.1f}%)\n"
        
        result_text += f"\nâœ“ GPUæ¨¡æ“¬æ•¸æ“šå·²æ•´åˆåˆ°æ­·å²è¨˜éŒ„ä¸­ï¼Œå…±{len(results['detailed_results'])}ç­†è©³ç´°è¨˜éŒ„"
        result_text += f"\nâœ“ ä½¿ç”¨v3.8.4é«˜æ¨è–¦ç‡å„ªåŒ–ç³»çµ± - æ¨è–¦ç‡å¤§å¹…æå‡"
        
        messagebox.showinfo("GPUæ¨¡æ“¬çµæœ v3.8.4", result_text)
        
        self.data_status_label.config(text=f"GPUæ¨¡æ“¬å®Œæˆ - {speed:.0f}å±€/ç§’ - é«˜æ¨è–¦ç‡ç³»çµ±", fg='#00ff00')
        
        self.update_recommendation_display()

def calculate_gpu_recommendation_stats(self, detailed_results):
        """è¨ˆç®—GPUæ¨¡æ“¬çš„æ¨è–¦çµ±è¨ˆ"""
        stats = {
            'banker': {'bet': 0, 'win': 0, 'amount': 0, 'is_reverse': False},
            'player': {'bet': 0, 'win': 0, 'amount': 0, 'is_reverse': False},
            'tie': {'bet': 0, 'win': 0, 'amount': 0, 'is_reverse': False}
        }
        
        for result in detailed_results:
            bet_type = result.get('recommendation')
            bet_level = result.get('bet_level', 0)
            is_reverse = result.get('is_reverse', False)
            
            if bet_type and bet_level > 0:
                stats[bet_type]['bet'] += bet_level
                stats[bet_type]['is_reverse'] = is_reverse
                
                if result.get('result') == 'âœ“':
                    stats[bet_type]['win'] += bet_level
                    if bet_type == 'banker':
                        stats[bet_type]['amount'] += bet_level * 0.95
                    elif bet_type == 'player':
                        stats[bet_type]['amount'] += bet_level * 1.0
                    else:
                        stats[bet_type]['amount'] += bet_level * 7.0
                elif result.get('result') == 'âœ—âœ—':
                    stats[bet_type]['amount'] -= bet_level
        
        return stats

def convert_gpu_to_standard_history(self, results, num_simulations):
        """å°‡GPUæ¨¡æ“¬çµæœè½‰æ›ç‚ºæ¨™æº–æ­·å²æ ¼å¼"""
        detailed_results = results.get('detailed_results', [])
        
        for i, gpu_result in enumerate(detailed_results):
            record = {
                'round': self.game_count + i,
                'type': 'gpu_simulated',
                'cards': [],
                'banker_hand': gpu_result.get('banker_hand', []),
                'player_hand': gpu_result.get('player_hand', []),
                'banker_score': gpu_result.get('banker_score', 0),
                'player_score': gpu_result.get('player_score', 0),
                'winner': gpu_result.get('winner', ''),
                'winner_chinese': gpu_result.get('winner_chinese', ''),
                'recommendation': gpu_result.get('recommendation'),
                'recommendation_chinese': self.get_chinese_name(gpu_result.get('recommendation', '')),
                'bet_level': gpu_result.get('bet_level', 0),
                'is_reverse': gpu_result.get('is_reverse', False),
                'probabilities': gpu_result.get('probabilities', self.base_probabilities.copy()),
                'recommendation_result': gpu_result.get('result_text', ''),
                'changes': gpu_result.get('changes', {}),
                'timestamp': datetime.now(),
                'simulation_id': i,
                'consistency_version': 'v3.8.4-HR'
            }
            
            self.history.append(record)
        
        self.game_count += len(detailed_results)

def fallback_to_cpu_simulation(self, num_simulations):
        """å›é€€åˆ°CPUæ¨¡æ“¬"""
        messagebox.showinfo("åˆ‡æ›åˆ°CPU", "GPUæ¨¡æ“¬å¤±æ•—ï¼Œåˆ‡æ›åˆ°CPUæ¨¡æ“¬")
        self.start_auto_simulate()

def export_to_csv(self):
        if not self.history:
            messagebox.showinfo("æç¤º", "æ²’æœ‰æ­·å²æ•¸æ“šå¯å°å‡º")
            return
        
        filename = f"baccarat_simulation_v3.8.4_hr_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv"
        full_path = os.path.join(self.export_path, filename)
        
        os.makedirs(self.export_path, exist_ok=True)
        
        try:
            with open(full_path, 'w', newline='', encoding='utf-8-sig') as csvfile:
                fieldnames = [
                    'å±€æ•¸', 'é¡å‹', 'è´å®¶', 'èŠæ¦‚ç‡', 'é–’æ¦‚ç‡', 'å’Œæ¦‚ç‡', 
                    'èŠè®ŠåŒ–%', 'é–’è®ŠåŒ–%', 'å’Œè®ŠåŒ–%', 'æ¨è–¦', 'ä¸‹æ³¨ç­‰ç´š', 'æ˜¯å¦åå‘', 'çµæœ', 'æ™‚é–“æˆ³', 'ç‰ˆæœ¬'
                ]
                writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
                writer.writeheader()
                
                for round_data in self.history:
                    banker_change = self.calculate_percentage_change(
                        round_data['probabilities']['banker'], self.base_probabilities['banker'])
                    player_change = self.calculate_percentage_change(
                        round_data['probabilities']['player'], self.base_probabilities['player'])
                    tie_change = self.calculate_percentage_change(
                        round_data['probabilities']['tie'], self.base_probabilities['tie'])
                    writer.writerow({
                        'å±€æ•¸': round_data['round'],
                        'é¡å‹': 'GPUæ¨¡æ“¬' if round_data.get('type') == 'gpu_simulated' else 'æ­£å¸¸å°å±€',
                        'è´å®¶': round_data['winner_chinese'],
                        'èŠæ¦‚ç‡': round_data['probabilities']['banker'],
                        'é–’æ¦‚ç‡': round_data['probabilities']['player'],
                        'å’Œæ¦‚ç‡': round_data['probabilities']['tie'],
                        'èŠè®ŠåŒ–%': banker_change,
                        'é–’è®ŠåŒ–%': player_change,
                        'å’Œè®ŠåŒ–%': tie_change,
                        'æ¨è–¦': round_data['recommendation_chinese'],
                        'ä¸‹æ³¨ç­‰ç´š': round_data.get('bet_level', 0),
                        'æ˜¯å¦åå‘': 'æ˜¯' if round_data.get('is_reverse', False) else 'å¦',
                        'çµæœ': 'âœ“' if "âœ“" in round_data.get('recommendation_result', '') else 
                               'âœ—âœ—' if "âœ—âœ—" in round_data.get('recommendation_result', '') else 'â–â–',
                        'æ™‚é–“æˆ³': round_data.get('timestamp', datetime.now()).strftime('%Y-%m-%d %H:%M:%S'),
                        'ç‰ˆæœ¬': round_data.get('consistency_version', 'v3.8.4-HR')
                    })
            
            messagebox.showinfo("æˆåŠŸ", f"æ•¸æ“šå·²å°å‡ºåˆ°: {full_path}")
            
        except Exception as e:
            messagebox.showerror("éŒ¯èª¤", f"å°å‡ºå¤±æ•—: {str(e)}")

def show_history(self):
        if not self.history:
            messagebox.showinfo("æç¤º", "æ²’æœ‰æ­·å²è¨˜éŒ„")
            return
        
        history_window = tk.Toplevel(self.root)
        history_window.title("æ­·å²åˆ†æå ±å‘Š v3.8.4ï¼ˆé«˜æ¨è–¦ç‡å„ªåŒ–ç‰ˆï¼‰")
        history_window.geometry("1000x700")
        history_window.configure(bg='#2d2d2d')
        
        notebook = ttk.Notebook(history_window)
        notebook.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        text_frame = ttk.Frame(notebook)
        notebook.add(text_frame, text="æ–‡å­—å ±å‘Š")
        
        text_area = tk.Text(text_frame, font=('Microsoft YaHei', 9), 
                           fg='white', bg='#1a1a1a', wrap=tk.WORD)
        scrollbar = tk.Scrollbar(text_frame, command=text_area.yview)
        text_area.config(yscrollcommand=scrollbar.set)
        
        text_area.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        report = self.generate_history_report()
        text_area.insert(tk.END, report)
        text_area.config(state=tk.DISABLED)
        
        if self.gpu_simulation_history:
            gpu_frame = ttk.Frame(notebook)
            notebook.add(gpu_frame, text="GPUæ¨¡æ“¬æ­·å²")
            
            gpu_text = tk.Text(gpu_frame, font=('Microsoft YaHei', 9), 
                             fg='white', bg='#1a1a1a', wrap=tk.WORD)
            gpu_scrollbar = tk.Scrollbar(gpu_frame, command=gpu_text.yview)
            gpu_text.config(yscrollcommand=gpu_scrollbar.set)
            
            gpu_text.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
            gpu_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
            
            gpu_report = self.generate_gpu_history_report()
            gpu_text.insert(tk.END, gpu_report)
            gpu_text.config(state=tk.DISABLED)
        
        if MATPLOTLIB_AVAILABLE and len(self.history) > 1:
            chart_frame = ttk.Frame(notebook)
            notebook.add(chart_frame, text="è¶¨å‹¢åœ–")
            self.create_trend_chart(chart_frame)
        else:
            no_chart_frame = ttk.Frame(notebook)
            notebook.add(no_chart_frame, text="è¶¨å‹¢åœ–")
            
            label = tk.Label(no_chart_frame, text="åœ–è¡¨åŠŸèƒ½ä¸å¯ç”¨æˆ–æ•¸æ“šä¸è¶³", 
                           font=('Microsoft YaHei', 12), bg='#2d2d2d', fg='white')
            label.pack(expand=True)

def generate_history_report(self):
        """ç”Ÿæˆæ­·å²åˆ†æå ±å‘Š"""
        report = "=== ç™¾å®¶æ¨‚æ­·å²åˆ†æå ±å‘Š v3.8.4ï¼ˆé«˜æ¨è–¦ç‡å„ªåŒ–ç³»çµ±ï¼‰ ===\n\n"
        report += f"ç¸½å±€æ•¸: {len(self.history)}\n"
        report += f"Aç‰Œå‡ºç¾æ¬¡æ•¸: {self.a_count}\n"
        report += f"å‰©é¤˜ç‰Œæ•¸: {len(self.remaining_deck)}\n"
        report += f"æ¨è–¦ç¯„åœ: ç¬¬{self.THRESHOLD_min_games}~{self.THRESHOLD_max_games}å±€\n"
        report += f"å°å‡ºè·¯å¾‘: {self.export_path}\n"
        report += f"GPUåŠ é€Ÿ: {'å¯ç”¨' if self.gpu_enabled else 'ä¸å¯ç”¨'}\n"
        report += f"GPUæ¨¡æ“¬æ¬¡æ•¸: {len(self.gpu_simulation_history)}\n"
        report += f"è¶¨å‹¢éæ¿¾: {'å•Ÿç”¨' if self.trend_filter_enabled else 'ç¦ç”¨'}\n"
        report += f"æœ€å°è¶¨å‹¢å¼·åº¦: {self.min_trend_strength}\n"
        report += f"æœ€å¤§è¶¨å‹¢å¼·åº¦: {self.max_trend_strength}\n"
        report += f"ä¸‹æ³¨ç­–ç•¥: v3.8.4é«˜æ¨è–¦ç‡ç³»çµ±ï¼ˆæ¨è–¦ç‡45-65%ï¼‰\n\n"
        
        normal_games = [h for h in self.history if h.get('type') != 'gpu_simulated']
        gpu_games = [h for h in self.history if h.get('type') == 'gpu_simulated']
        
        if normal_games:
            banker_wins = sum(1 for h in normal_games if h['winner'] == 'banker')
            player_wins = sum(1 for h in normal_games if h['winner'] == 'player')
            tie_wins = sum(1 for h in normal_games if h['winner'] == 'tie')
            
            report += f"æ­£å¸¸å°å±€: {len(normal_games)}å±€\n"
            report += f"èŠå®¶å‹: {banker_wins}å±€ ({banker_wins/len(normal_games)*100:.1f}%)\n"
            report += f"é–’å®¶å‹: {player_wins}å±€ ({player_wins/len(normal_games)*100:.1f}%)\n"
            report += f"å’Œå±€: {tie_wins}å±€ ({tie_wins/len(normal_games)*100:.1f}%)\n\n"
        
        if gpu_games:
            banker_wins = sum(1 for h in gpu_games if h['winner'] == 'banker')
            player_wins = sum(1 for h in gpu_games if h['winner'] == 'player')
            tie_wins = sum(1 for h in gpu_games if h['winner'] == 'tie')
            
            report += f"GPUæ¨¡æ“¬: {len(gpu_games)}å±€\n"
            report += f"èŠå®¶å‹: {banker_wins}å±€ ({banker_wins/len(gpu_games)*100:.1f}%)\n"
            report += f"é–’å®¶å‹: {player_wins}å±€ ({player_wins/len(gpu_games)*100:.1f}%)\n"
            report += f"å’Œå±€: {tie_wins}å±€ ({tie_wins/len(gpu_games)*100:.1f}%)\n\n"
        
        # æ¨è–¦é …ç›®çµ±è¨ˆ
        report += "=== æ¨è–¦é …ç›®çµ±è¨ˆ ===\n"
        chinese_names = {
            'banker': 'èŠ', 'player': 'é–’', 'tie': 'å’Œ'
        }
        
        total_bet = 0
        total_win = 0
        total_amount = 0
        reverse_bet = 0
        
        # åˆä½µæ‰€æœ‰æ­·å²è¨˜éŒ„çš„æ¨è–¦çµ±è¨ˆ
        all_stats = {
            'banker': {'bet': 0, 'win': 0, 'amount': 0, 'reverse': 0},
            'player': {'bet': 0, 'win': 0, 'amount': 0, 'reverse': 0},
            'tie': {'bet': 0, 'win': 0, 'amount': 0, 'reverse': 0}
        }
        
        # è¨ˆç®—æ‰€æœ‰æ­·å²è¨˜éŒ„çš„æ¨è–¦çµ±è¨ˆ
        for record in self.history:
            if record.get('recommendation') and record.get('bet_level', 0) > 0:
                bet_type = record['recommendation']
                bet_level = record['bet_level']
                is_reverse = record.get('is_reverse', False)
                
                all_stats[bet_type]['bet'] += bet_level
                if is_reverse:
                    all_stats[bet_type]['reverse'] += bet_level
                    reverse_bet += bet_level
                
                if "âœ“" in record.get('recommendation_result', ''):
                    all_stats[bet_type]['win'] += bet_level
                    if bet_type == 'banker':
                        all_stats[bet_type]['amount'] += bet_level * 0.95
                    elif bet_type == 'player':
                        all_stats[bet_type]['amount'] += bet_level * 1.0
                    else:
                        all_stats[bet_type]['amount'] += bet_level * 7.0
                elif "âœ—âœ—" in record.get('recommendation_result', ''):
                    all_stats[bet_type]['amount'] -= bet_level
        
        for bet_type, stats in all_stats.items():
            if stats['bet'] > 0:
                win_rate = stats['win'] / stats['bet'] * 100 if stats['bet'] > 0 else 0
                reverse_rate = stats['reverse'] / stats['bet'] * 100 if stats['bet'] > 0 else 0
                chinese_name = chinese_names.get(bet_type, bet_type)
                report += f"æ¨è–¦{chinese_name}: {stats['win']}/{stats['bet']} ({win_rate:.1f}%)ï¼Œåå‘: {reverse_rate:.1f}%ï¼Œæ·¨åˆ©: {stats['amount']:.2f}\n"
                total_bet += stats['bet']
                total_win += stats['win']
                total_amount += stats['amount']
        
        if total_bet > 0:
            overall_win_rate = total_win / total_bet * 100
            overall_reverse_rate = reverse_bet / total_bet * 100
            report += f"\nç¸½è¨ˆ: {total_win}/{total_bet} ({overall_win_rate:.1f}%)ï¼Œç¸½æ·¨åˆ©: {total_amount:.2f}\n"
            report += f"åå‘æ¨è–¦æ¯”ä¾‹: {overall_reverse_rate:.1f}%\n"
        else:
            report += "å°šç„¡æ¨è–¦ä¸‹æ³¨è¨˜éŒ„"
        
        report += "\n"
        
        report += "æœ€è¿‘10å±€è¨˜éŒ„:\n"
        report += "-" * 70 + "\n"
        
        recent_games = self.history[-10:]
        for i, round_data in enumerate(recent_games, 1):
            game_type = "GPU" if round_data.get('type') == 'gpu_simulated' else "æ­£å¸¸"
            report += f"ç¬¬{round_data['round']}å±€({game_type}): "
            
            if 'player_score' in round_data and 'banker_score' in round_data:
                report += f"é–’{round_data['player_score']} VS èŠ{round_data['banker_score']} - "
            else:
                report += f"{round_data['winner_chinese']}è´ - "
            
            if round_data['recommendation']:
                if "âœ“" in round_data['recommendation_result']:
                    win_symbol = "âœ“"
                elif "âœ—âœ—" in round_data['recommendation_result']:
                    win_symbol = "âœ—âœ—"
                else:
                    win_symbol = "â–â–"
                    
                reverse_indicator = "ğŸ”„ğŸ”„" if round_data.get('is_reverse', False) else ""
                report += f"æ¨è–¦{reverse_indicator}({round_data['recommendation_chinese']})ï¼Œ{round_data['winner_chinese']}è´ {win_symbol}\n"
            else:
                report += f"ç„¡æ¨è–¦ï¼Œ{round_data['winner_chinese']}è´\n"
        
        return report

def generate_gpu_history_report(self):
        report = "=== GPUæ¨¡æ“¬æ­·å²å ±å‘Š v3.8.4 ===\n\n"
        
        if not self.gpu_simulation_history:
            report += "å°šç„¡GPUæ¨¡æ“¬è¨˜éŒ„\n"
            return report
        
        total_simulations = sum(sim['num_simulations'] for sim in self.gpu_simulation_history)
        total_time = sum(sim.get('performance', {}).get('total_time', 0) for sim in self.gpu_simulation_history)
        avg_speed = total_simulations / total_time if total_time > 0 else 0
        
        # è¨ˆç®—ç¸½åå‘æ¨è–¦æ¯”ä¾‹
        total_reverse_count = 0
        total_recommendations = 0
        for sim in self.gpu_simulation_history:
            for result in sim.get('detailed_results', []):
                if result.get('recommendation'):
                    total_recommendations += 1
                    if result.get('is_reverse', False):
                        total_reverse_count += 1
        
        overall_reverse_rate = (total_reverse_count / total_recommendations * 100) if total_recommendations > 0 else 0
        
        report += f"ç¸½æ¨¡æ“¬æ¬¡æ•¸: {len(self.gpu_simulation_history)}æ¬¡\n"
        report += f"ç¸½æ¨¡æ“¬å±€æ•¸: {total_simulations:,}å±€\n"
        report += f"ç¸½æ¨¡æ“¬æ™‚é–“: {total_time:.2f}ç§’\n"
        report += f"å¹³å‡é€Ÿåº¦: {avg_speed:.0f}å±€/ç§’\n"
        report += f"ç¸½æ¨è–¦æ¬¡æ•¸: {total_recommendations}æ¬¡\n"
        report += f"ç¸½åå‘æ¨è–¦: {total_reverse_count}æ¬¡ ({overall_reverse_rate:.1f}%)\n"
        report += f"ç³»çµ±ç‰ˆæœ¬: v3.8.4é«˜æ¨è–¦ç‡ç³»çµ±\n\n"
        
        report += "è©³ç´°æ¨¡æ“¬è¨˜éŒ„:\n"
        report += "=" * 80 + "\n"
        
        for i, sim in enumerate(self.gpu_simulation_history, 1):
            results = sim['results']
            performance = sim.get('performance', {})
            
            # è¨ˆç®—æœ¬æ¬¡æ¨¡æ“¬çš„åå‘æ¨è–¦æ¯”ä¾‹
            reverse_count = 0
            total_recs = 0
            for result in sim.get('detailed_results', []):
                if result.get('recommendation'):
                    total_recs += 1
                    if result.get('is_reverse', False):
                        reverse_count += 1
            
            reverse_rate = (reverse_count / total_recs * 100) if total_recs > 0 else 0
            
            report += f"æ¨¡æ“¬ #{i}:\n"
            report += f"  æ™‚é–“: {sim['timestamp'].strftime('%Y-%m-%d %H:%M:%S')}\n"
            report += f"  å±€æ•¸: {sim['num_simulations']:,}å±€\n"
            report += f"  ç”¨æ™‚: {performance.get('total_time', 0):.2f}ç§’\n"
            report += f"  é€Ÿåº¦: {performance.get('games_per_second', 0):.0f}å±€/ç§’\n"
            report += f"  çµæœ: èŠ{results['banker_wins']}å±€({results['banker_win_rate']:.2f}%) | "
            report += f"é–’{results['player_wins']}å±€({results['player_win_rate']:.2f}%) | "
            report += f"å’Œ{results['ties']}å±€({results['tie_rate']:.2f}%)\n"
            report += f"  åå‘æ¨è–¦: {reverse_count}/{total_recs} ({reverse_rate:.1f}%)\n"
            report += "-" * 80 + "\n"
        
        return report

def create_trend_chart(self, parent):
        """å‰µå»ºè¶¨å‹¢åœ–è¡¨"""
        if not MATPLOTLIB_AVAILABLE or len(self.history) < 2:
            label = tk.Label(parent, text="æ•¸æ“šä¸è¶³æˆ–åœ–è¡¨åŠŸèƒ½ä¸å¯ç”¨", 
                           font=('Microsoft YaHei', 12), bg='#2d2d2d', fg='white')
            label.pack(expand=True)
            return
        
        # åŒ…å«æ‰€æœ‰æ­·å²æ•¸æ“šï¼ˆæ­£å¸¸å°å±€å’ŒGPUæ¨¡æ“¬ï¼‰
        all_games = [h for h in self.history if 'probabilities' in h]
        if len(all_games) < 2:
            label = tk.Label(parent, text="æ•¸æ“šä¸è¶³", 
                           font=('Microsoft YaHei', 12), bg='#2d2d2d', fg='white')
            label.pack(expand=True)
            return
        
        fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(10, 8))
        fig.patch.set_facecolor('#2d2d2d')
        
        # æ¦‚ç‡è¶¨å‹¢åœ–
        rounds = [h['round'] for h in all_games]
        banker_probs = [h['probabilities']['banker'] for h in all_games]
        player_probs = [h['probabilities']['player'] for h in all_games]
        tie_probs = [h['probabilities']['tie'] for h in all_games]
        
        # ä½¿ç”¨ä¸åŒé¡è‰²æ¨™è¨˜GPUæ¨¡æ“¬æ•¸æ“šé»
        gpu_indices = [i for i, h in enumerate(all_games) if h.get('type') == 'gpu_simulated']
        normal_indices = [i for i, h in enumerate(all_games) if h.get('type') != 'gpu_simulated']
        
        # æ¨™è¨˜åå‘æ¨è–¦é»
        reverse_indices = [i for i, h in enumerate(all_games) if h.get('is_reverse', False)]
        
        # ç¹ªè£½æ­£å¸¸å°å±€ç·šæ¢
        ax1.plot(rounds, banker_probs, label='èŠå®¶æ¦‚ç‡', color='#4ecdc4', linewidth=2, alpha=0.7)
        ax1.plot(rounds, player_probs, label='é–’å®¶æ¦‚ç‡', color='#ff6b6b', linewidth=2, alpha=0.7)
        ax1.plot(rounds, tie_probs, label='å’Œå±€æ¦‚ç‡', color='#45b7d1', linewidth=2, alpha=0.7)
        
        # æ¨™è¨˜GPUæ¨¡æ“¬æ•¸æ“šé»
        if gpu_indices:
            gpu_rounds = [rounds[i] for i in gpu_indices]
            gpu_banker = [banker_probs[i] for i in gpu_indices]
            gpu_player = [player_probs[i] for i in gpu_indices]
            gpu_tie = [tie_probs[i] for i in gpu_indices]
            
            ax1.scatter(gpu_rounds, gpu_banker, color='#4ecdc4', s=30, alpha=0.8, marker='o', label='GPU-èŠ')
            ax1.scatter(gpu_rounds, gpu_player, color='#ff6b6b', s=30, alpha=0.8, marker='s', label='GPU-é–’')
            ax1.scatter(gpu_rounds, gpu_tie, color='#45b7d1', s=30, alpha=0.8, marker='^', label='GPU-å’Œ')
        
        # æ¨™è¨˜åå‘æ¨è–¦é»
        if reverse_indices:
            reverse_rounds = [rounds[i] for i in reverse_indices]
            reverse_probs = [banker_probs[i] for i in reverse_indices]  # ä½¿ç”¨èŠå®¶æ¦‚ç‡ä½œç‚ºyåæ¨™
            ax1.scatter(reverse_rounds, reverse_probs, color='#ff00ff', s=100, alpha=0.8, marker='*', label='åå‘æ¨è–¦')
        
        ax1.axhline(y=self.base_probabilities['banker'], color='#4ecdc4', linestyle='--', alpha=0.5)
        ax1.axhline(y=self.base_probabilities['player'], color='#ff6b6b', linestyle='--', alpha=0.5)
        ax1.axhline(y=self.base_probabilities['tie'], color='#45b7d1', linestyle='--', alpha=0.5)
        
        ax1.set_title('æ¦‚ç‡è¶¨å‹¢åœ– v3.8.4ï¼ˆé«˜æ¨è–¦ç‡å„ªåŒ–ç³»çµ±ï¼‰', color='white', fontsize=14)
        ax1.set_xlabel('å±€æ•¸', color='white')
        ax1.set_ylabel('æ¦‚ç‡ (%)', color='white')
        ax1.legend()
        ax1.grid(True, alpha=0.3)
        ax1.set_facecolor('#1a1a1a')
        ax1.tick_params(colors='white')
        
        # ç›ˆåˆ©è¶¨å‹¢åœ–
        cumulative_profit = []
        current_profit = 0
        
        for h in all_games:
            if 'recommendation' in h and h['recommendation'] and 'bet_level' in h:
                bet_type = h['recommendation']
                bet_level = h['bet_level']
                
                if "âœ“" in h.get('recommendation_result', ''):
                    if bet_type == 'banker':
                        current_profit += bet_level * 0.95
                    elif bet_type == 'player':
                        current_profit += bet_level * 1.0
                    else:
                        current_profit += bet_level * 7
                elif "âœ—âœ—" in h.get('recommendation_result', ''):
                    current_profit -= bet_level
            cumulative_profit.append(current_profit)
        
        ax2.plot(rounds, cumulative_profit, label='ç´¯è¨ˆç›ˆåˆ©', color='#2ecc71', linewidth=2)
        
        # æ¨™è¨˜GPUæ¨¡æ“¬çš„ç›ˆåˆ©é»
        if gpu_indices:
            gpu_profits = [cumulative_profit[i] for i in gpu_indices]
            ax2.scatter(gpu_rounds, gpu_profits, color='#2ecc71', s=50, alpha=0.8, marker='*', label='GPUæ¨¡æ“¬é»')
        
        # æ¨™è¨˜åå‘æ¨è–¦çš„ç›ˆåˆ©é»
        if reverse_indices:
            reverse_profits = [cumulative_profit[i] for i in reverse_indices]
            ax2.scatter(reverse_rounds, reverse_profits, color='#ff00ff', s=100, alpha=0.8, marker='*', label='åå‘æ¨è–¦é»')
        
        ax2.axhline(y=0, color='white', linestyle='-', alpha=0.5)
        
        ax2.set_title('ç›ˆåˆ©è¶¨å‹¢åœ– v3.8.4ï¼ˆé«˜æ¨è–¦ç‡å„ªåŒ–ç³»çµ±ï¼‰', color='white', fontsize=14)
        ax2.set_xlabel('å±€æ•¸', color='white')
        ax2.set_ylabel('ç›ˆåˆ©', color='white')
        ax2.legend()
        ax2.grid(True, alpha=0.3)
        ax2.set_facecolor('#1a1a1a')
        ax2.tick_params(colors='white')
        
        plt.tight_layout()
        
        canvas = FigureCanvasTkAgg(fig, parent)
        canvas.draw()
        canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True)

# ä¸»ç¨‹åºå…¥å£
if __name__ == "__main__":
    root = tk.Tk()
    app = BaccaratAIAssistant(root)
    root.mainloop()